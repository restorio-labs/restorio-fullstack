diff --git a/app/api/alembic/fixture.py b/app/api/alembic/fixture.py
new file mode 100644
index 0000000..0beba1b
--- /dev/null
+++ b/app/api/alembic/fixture.py
@@ -0,0 +1,837 @@
+"""
+Dev seed script â€” realistic fixture data for local/staging environments.
+
+Usage:
+    python seed_dev.py
+
+Requires DATABASE_URL in environment (or .env file via python-dotenv).
+Passwords are bcrypt-hashed. All plaintext passwords are "password123".
+
+Safe to re-run: wraps everything in a transaction and rolls back on error.
+"""
+
+from datetime import UTC, datetime, timedelta
+import json
+import os
+import uuid
+
+import sqlalchemy as sa  # noqa: F401
+from sqlalchemy import create_engine, text
+
+# ---------------------------------------------------------------------------
+# Connection
+# ---------------------------------------------------------------------------
+
+DATABASE_URL = os.environ.get("DATABASE_URL")
+if not DATABASE_URL:
+    msg = "DATABASE_URL environment variable is not set."
+    raise RuntimeError(msg)
+
+engine = create_engine(DATABASE_URL)
+
+# ---------------------------------------------------------------------------
+# Helpers
+# ---------------------------------------------------------------------------
+
+
+def uid() -> str:
+    return str(uuid.uuid4())
+
+
+def now(offset_days: int = 0, offset_hours: int = 0) -> datetime:
+    base = datetime.now(UTC)
+    return base + timedelta(days=offset_days, hours=offset_hours)
+
+
+# bcrypt hash of "password123" â€” pre-computed so we don't need bcrypt at seed time
+PASSWORD_HASH = "$2b$12$KIXuO3Hmq2lHzC4tRS5A5.qhJpJpRKQUaGEeMdm0bA7Wf8MMYZ3NK"
+
+# ---------------------------------------------------------------------------
+# IDs â€” defined upfront so foreign keys can reference them freely
+# ---------------------------------------------------------------------------
+
+# Tenants
+TENANT_BISTRO = uid()
+TENANT_PIZZA = uid()
+TENANT_CAFE = uid()
+
+# Users â€” Bistro
+U_BISTRO_OWNER = uid()
+U_BISTRO_MANAGER = uid()
+U_BISTRO_WAITER1 = uid()
+U_BISTRO_WAITER2 = uid()
+U_BISTRO_KITCHEN = uid()
+
+# Users â€” Pizza Palace
+U_PIZZA_OWNER = uid()
+U_PIZZA_WAITER = uid()
+U_PIZZA_KITCHEN = uid()
+
+# Users â€” Cafe (suspended tenant, minimal data)
+U_CAFE_OWNER = uid()
+
+# Venues
+V_BISTRO_MAIN = uid()
+V_BISTRO_TERRACE = uid()
+V_PIZZA_MAIN = uid()
+
+# Floor canvases
+FC_BISTRO_MAIN_V1 = uid()
+FC_BISTRO_MAIN_V2 = uid()
+FC_BISTRO_TERRACE_V1 = uid()
+FC_PIZZA_MAIN_V1 = uid()
+
+# Tables â€” Bistro main floor
+RT_B1 = uid()
+RT_B2 = uid()
+RT_B3 = uid()
+RT_B4 = uid()
+RT_B5 = uid()
+# Tables â€” Bistro terrace
+RT_BT1 = uid()
+RT_BT2 = uid()
+# Tables â€” Pizza Palace
+RT_P1 = uid()
+RT_P2 = uid()
+RT_P3 = uid()
+
+# Orders
+O1 = uid()
+O2 = uid()
+O3 = uid()
+O4 = uid()
+O5 = uid()
+O6 = uid()
+
+# Order items
+OI1a = uid()
+OI1b = uid()
+OI1c = uid()
+OI2a = uid()
+OI2b = uid()
+OI3a = uid()
+OI3b = uid()
+OI3c = uid()
+OI4a = uid()
+OI4b = uid()
+OI5a = uid()
+OI5b = uid()
+OI6a = uid()
+
+# Payments
+PAY1 = uid()
+PAY2 = uid()
+PAY3 = uid()
+PAY4 = uid()
+PAY5 = uid()
+
+
+# ---------------------------------------------------------------------------
+# Data definitions
+# ---------------------------------------------------------------------------
+
+TENANTS = [
+    {
+        "id": TENANT_BISTRO,
+        "name": "The Grand Bistro",
+        "slug": "grand-bistro",
+        "status": "ACTIVE",
+        "owner_id": U_BISTRO_OWNER,
+        "created_at": now(offset_days=-60),
+    },
+    {
+        "id": TENANT_PIZZA,
+        "name": "Pizza Palace",
+        "slug": "pizza-palace",
+        "status": "ACTIVE",
+        "owner_id": U_PIZZA_OWNER,
+        "created_at": now(offset_days=-30),
+    },
+    {
+        "id": TENANT_CAFE,
+        "name": "Corner CafÃ©",
+        "slug": "corner-cafe",
+        "status": "SUSPENDED",
+        "owner_id": U_CAFE_OWNER,
+        "created_at": now(offset_days=-10),
+    },
+]
+
+USERS = [
+    # --- Grand Bistro ---
+    {
+        "id": U_BISTRO_OWNER,
+        "email": "owner@grand-bistro.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "owner",
+        "is_active": True,
+        "tenant_id": TENANT_BISTRO,
+        "created_at": now(offset_days=-60),
+    },
+    {
+        "id": U_BISTRO_MANAGER,
+        "email": "manager@grand-bistro.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "manager",
+        "is_active": True,
+        "tenant_id": TENANT_BISTRO,
+        "created_at": now(offset_days=-58),
+    },
+    {
+        "id": U_BISTRO_WAITER1,
+        "email": "waiter1@grand-bistro.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "waiter",
+        "is_active": True,
+        "tenant_id": TENANT_BISTRO,
+        "created_at": now(offset_days=-55),
+    },
+    {
+        "id": U_BISTRO_WAITER2,
+        "email": "waiter2@grand-bistro.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "waiter",
+        "is_active": False,  # deactivated â€” useful edge case
+        "tenant_id": TENANT_BISTRO,
+        "created_at": now(offset_days=-50),
+    },
+    {
+        "id": U_BISTRO_KITCHEN,
+        "email": "kitchen@grand-bistro.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "kitchen",
+        "is_active": True,
+        "tenant_id": TENANT_BISTRO,
+        "created_at": now(offset_days=-55),
+    },
+    # --- Pizza Palace ---
+    {
+        "id": U_PIZZA_OWNER,
+        "email": "owner@pizza-palace.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "owner",
+        "is_active": True,
+        "tenant_id": TENANT_PIZZA,
+        "created_at": now(offset_days=-30),
+    },
+    {
+        "id": U_PIZZA_WAITER,
+        "email": "waiter@pizza-palace.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "waiter",
+        "is_active": True,
+        "tenant_id": TENANT_PIZZA,
+        "created_at": now(offset_days=-28),
+    },
+    {
+        "id": U_PIZZA_KITCHEN,
+        "email": "kitchen@pizza-palace.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "kitchen",
+        "is_active": True,
+        "tenant_id": TENANT_PIZZA,
+        "created_at": now(offset_days=-28),
+    },
+    # --- Corner CafÃ© (suspended) ---
+    {
+        "id": U_CAFE_OWNER,
+        "email": "owner@corner-cafe.dev",
+        "password_hash": PASSWORD_HASH,
+        "account_type": "owner",
+        "is_active": True,
+        "tenant_id": TENANT_CAFE,
+        "created_at": now(offset_days=-10),
+    },
+]
+
+USER_TENANTS = [
+    # Bistro
+    {
+        "user_id": U_BISTRO_OWNER,
+        "tenant_id": TENANT_BISTRO,
+        "role": "owner",
+        "created_at": now(offset_days=-60),
+    },
+    {
+        "user_id": U_BISTRO_MANAGER,
+        "tenant_id": TENANT_BISTRO,
+        "role": "manager",
+        "created_at": now(offset_days=-58),
+    },
+    {
+        "user_id": U_BISTRO_WAITER1,
+        "tenant_id": TENANT_BISTRO,
+        "role": "waiter",
+        "created_at": now(offset_days=-55),
+    },
+    {
+        "user_id": U_BISTRO_WAITER2,
+        "tenant_id": TENANT_BISTRO,
+        "role": "waiter",
+        "created_at": now(offset_days=-50),
+    },
+    {
+        "user_id": U_BISTRO_KITCHEN,
+        "tenant_id": TENANT_BISTRO,
+        "role": "kitchen",
+        "created_at": now(offset_days=-55),
+    },
+    # Pizza Palace
+    {
+        "user_id": U_PIZZA_OWNER,
+        "tenant_id": TENANT_PIZZA,
+        "role": "owner",
+        "created_at": now(offset_days=-30),
+    },
+    {
+        "user_id": U_PIZZA_WAITER,
+        "tenant_id": TENANT_PIZZA,
+        "role": "waiter",
+        "created_at": now(offset_days=-28),
+    },
+    {
+        "user_id": U_PIZZA_KITCHEN,
+        "tenant_id": TENANT_PIZZA,
+        "role": "kitchen",
+        "created_at": now(offset_days=-28),
+    },
+    # CafÃ©
+    {
+        "user_id": U_CAFE_OWNER,
+        "tenant_id": TENANT_CAFE,
+        "role": "owner",
+        "created_at": now(offset_days=-10),
+    },
+]
+
+VENUES = [
+    {
+        "id": V_BISTRO_MAIN,
+        "tenant_id": TENANT_BISTRO,
+        "name": "Main Floor",
+        "active_layout_version_id": FC_BISTRO_MAIN_V2,  # points to latest canvas
+        "created_at": now(offset_days=-59),
+        "updated_at": now(offset_days=-5),
+    },
+    {
+        "id": V_BISTRO_TERRACE,
+        "tenant_id": TENANT_BISTRO,
+        "name": "Terrace",
+        "active_layout_version_id": FC_BISTRO_TERRACE_V1,
+        "created_at": now(offset_days=-59),
+        "updated_at": now(offset_days=-59),
+    },
+    {
+        "id": V_PIZZA_MAIN,
+        "tenant_id": TENANT_PIZZA,
+        "name": "Dining Room",
+        "active_layout_version_id": FC_PIZZA_MAIN_V1,
+        "created_at": now(offset_days=-29),
+        "updated_at": now(offset_days=-29),
+    },
+]
+
+_bistro_elements_v1 = [
+    {"type": "table", "table_id": RT_B1, "x": 50, "y": 50, "w": 80, "h": 80},
+    {"type": "table", "table_id": RT_B2, "x": 200, "y": 50, "w": 80, "h": 80},
+    {"type": "table", "table_id": RT_B3, "x": 350, "y": 50, "w": 80, "h": 80},
+]
+_bistro_elements_v2 = [
+    *_bistro_elements_v1,
+    {"type": "table", "table_id": RT_B4, "x": 50, "y": 200, "w": 80, "h": 80},
+    {"type": "table", "table_id": RT_B5, "x": 200, "y": 200, "w": 80, "h": 80},
+    {"type": "wall", "x": 0, "y": 150, "w": 800, "h": 10},
+]
+
+FLOOR_CANVASES = [
+    {
+        "id": FC_BISTRO_MAIN_V1,
+        "venue_id": V_BISTRO_MAIN,
+        "name": "Main Floor â€” v1",
+        "width": 800,
+        "height": 600,
+        "elements": _bistro_elements_v1,
+        "version": 1,
+        "created_at": now(offset_days=-59),
+        "updated_at": now(offset_days=-59),
+    },
+    {
+        "id": FC_BISTRO_MAIN_V2,
+        "venue_id": V_BISTRO_MAIN,
+        "name": "Main Floor â€” v2",
+        "width": 800,
+        "height": 600,
+        "elements": _bistro_elements_v2,
+        "version": 2,
+        "created_at": now(offset_days=-5),
+        "updated_at": now(offset_days=-5),
+    },
+    {
+        "id": FC_BISTRO_TERRACE_V1,
+        "venue_id": V_BISTRO_TERRACE,
+        "name": "Terrace Layout",
+        "width": 600,
+        "height": 400,
+        "elements": [
+            {"type": "table", "table_id": RT_BT1, "x": 50, "y": 50, "w": 80, "h": 80},
+            {"type": "table", "table_id": RT_BT2, "x": 200, "y": 50, "w": 80, "h": 80},
+        ],
+        "version": 1,
+        "created_at": now(offset_days=-59),
+        "updated_at": now(offset_days=-59),
+    },
+    {
+        "id": FC_PIZZA_MAIN_V1,
+        "venue_id": V_PIZZA_MAIN,
+        "name": "Dining Room Layout",
+        "width": 800,
+        "height": 600,
+        "elements": [
+            {"type": "table", "table_id": RT_P1, "x": 100, "y": 100, "w": 80, "h": 80},
+            {"type": "table", "table_id": RT_P2, "x": 250, "y": 100, "w": 80, "h": 80},
+            {"type": "table", "table_id": RT_P3, "x": 400, "y": 100, "w": 120, "h": 80},
+        ],
+        "version": 1,
+        "created_at": now(offset_days=-29),
+        "updated_at": now(offset_days=-29),
+    },
+]
+
+RESTAURANT_TABLES = [
+    # Grand Bistro â€” main floor
+    {
+        "id": RT_B1,
+        "tenant_id": TENANT_BISTRO,
+        "label": "B1",
+        "capacity": 2,
+        "is_active": True,
+        "created_at": now(offset_days=-59),
+    },
+    {
+        "id": RT_B2,
+        "tenant_id": TENANT_BISTRO,
+        "label": "B2",
+        "capacity": 4,
+        "is_active": True,
+        "created_at": now(offset_days=-59),
+    },
+    {
+        "id": RT_B3,
+        "tenant_id": TENANT_BISTRO,
+        "label": "B3",
+        "capacity": 4,
+        "is_active": True,
+        "created_at": now(offset_days=-59),
+    },
+    {
+        "id": RT_B4,
+        "tenant_id": TENANT_BISTRO,
+        "label": "B4",
+        "capacity": 6,
+        "is_active": True,
+        "created_at": now(offset_days=-5),
+    },
+    {
+        "id": RT_B5,
+        "tenant_id": TENANT_BISTRO,
+        "label": "B5",
+        "capacity": 6,
+        "is_active": False,
+        "created_at": now(offset_days=-5),
+    },  # inactive
+    # Grand Bistro â€” terrace
+    {
+        "id": RT_BT1,
+        "tenant_id": TENANT_BISTRO,
+        "label": "T1",
+        "capacity": 2,
+        "is_active": True,
+        "created_at": now(offset_days=-59),
+    },
+    {
+        "id": RT_BT2,
+        "tenant_id": TENANT_BISTRO,
+        "label": "T2",
+        "capacity": 4,
+        "is_active": True,
+        "created_at": now(offset_days=-59),
+    },
+    # Pizza Palace
+    {
+        "id": RT_P1,
+        "tenant_id": TENANT_PIZZA,
+        "label": "P1",
+        "capacity": 2,
+        "is_active": True,
+        "created_at": now(offset_days=-29),
+    },
+    {
+        "id": RT_P2,
+        "tenant_id": TENANT_PIZZA,
+        "label": "P2",
+        "capacity": 4,
+        "is_active": True,
+        "created_at": now(offset_days=-29),
+    },
+    {
+        "id": RT_P3,
+        "tenant_id": TENANT_PIZZA,
+        "label": "P3",
+        "capacity": 8,
+        "is_active": True,
+        "created_at": now(offset_days=-29),
+    },
+]
+
+ORDERS = [
+    # Bistro â€” completed and paid
+    {
+        "id": O1,
+        "tenant_id": TENANT_BISTRO,
+        "table_id": RT_B1,
+        "status": "COMPLETED",
+        "total_amount": "67.50",
+        "currency": "PLN",
+        "created_at": now(offset_days=-1, offset_hours=-3),
+        "updated_at": now(offset_days=-1, offset_hours=-1),
+    },
+    # Bistro â€” open/in progress
+    {
+        "id": O2,
+        "tenant_id": TENANT_BISTRO,
+        "table_id": RT_B2,
+        "status": "IN_PROGRESS",
+        "total_amount": "43.00",
+        "currency": "PLN",
+        "created_at": now(offset_hours=-1),
+        "updated_at": now(offset_hours=-1),
+    },
+    # Bistro â€” pending (just placed)
+    {
+        "id": O3,
+        "tenant_id": TENANT_BISTRO,
+        "table_id": RT_B3,
+        "status": "PENDING",
+        "total_amount": "29.00",
+        "currency": "PLN",
+        "created_at": now(offset_hours=-0),
+        "updated_at": now(offset_hours=-0),
+    },
+    # Bistro â€” cancelled
+    {
+        "id": O4,
+        "tenant_id": TENANT_BISTRO,
+        "table_id": RT_BT1,
+        "status": "CANCELLED",
+        "total_amount": "0.00",
+        "currency": "PLN",
+        "created_at": now(offset_days=-2),
+        "updated_at": now(offset_days=-2),
+    },
+    # Pizza Palace â€” completed
+    {
+        "id": O5,
+        "tenant_id": TENANT_PIZZA,
+        "table_id": RT_P1,
+        "status": "COMPLETED",
+        "total_amount": "55.00",
+        "currency": "PLN",
+        "created_at": now(offset_days=-1, offset_hours=-2),
+        "updated_at": now(offset_days=-1, offset_hours=-1),
+    },
+    # Pizza Palace â€” in progress
+    {
+        "id": O6,
+        "tenant_id": TENANT_PIZZA,
+        "table_id": RT_P2,
+        "status": "IN_PROGRESS",
+        "total_amount": "38.00",
+        "currency": "PLN",
+        "created_at": now(offset_hours=-2),
+        "updated_at": now(offset_hours=-2),
+    },
+]
+
+ORDER_ITEMS = [
+    # O1 â€” Bistro completed order
+    {
+        "id": OI1a,
+        "order_id": O1,
+        "product_id": "prod-bistro-001",
+        "name_snapshot": "Duck Confit",
+        "quantity": 2,
+        "unit_price": "24.50",
+        "created_at": now(offset_days=-1, offset_hours=-3),
+    },
+    {
+        "id": OI1b,
+        "order_id": O1,
+        "product_id": "prod-bistro-005",
+        "name_snapshot": "House Red Wine",
+        "quantity": 1,
+        "unit_price": "12.00",
+        "created_at": now(offset_days=-1, offset_hours=-3),
+    },
+    {
+        "id": OI1c,
+        "order_id": O1,
+        "product_id": "prod-bistro-010",
+        "name_snapshot": "CrÃ¨me BrÃ»lÃ©e",
+        "quantity": 1,
+        "unit_price": "6.50",
+        "created_at": now(offset_days=-1, offset_hours=-3),
+    },
+    # O2 â€” Bistro in-progress
+    {
+        "id": OI2a,
+        "order_id": O2,
+        "product_id": "prod-bistro-002",
+        "name_snapshot": "Beef Tartare",
+        "quantity": 1,
+        "unit_price": "28.00",
+        "created_at": now(offset_hours=-1),
+    },
+    {
+        "id": OI2b,
+        "order_id": O2,
+        "product_id": "prod-bistro-006",
+        "name_snapshot": "Sparkling Water",
+        "quantity": 3,
+        "unit_price": "5.00",
+        "created_at": now(offset_hours=-1),
+    },
+    # O3 â€” Bistro pending
+    {
+        "id": OI3a,
+        "order_id": O3,
+        "product_id": "prod-bistro-003",
+        "name_snapshot": "French Onion Soup",
+        "quantity": 2,
+        "unit_price": "9.50",
+        "created_at": now(),
+    },
+    {
+        "id": OI3b,
+        "order_id": O3,
+        "product_id": "prod-bistro-004",
+        "name_snapshot": "Caesar Salad",
+        "quantity": 1,
+        "unit_price": "7.50",
+        "created_at": now(),
+    },
+    {
+        "id": OI3c,
+        "order_id": O3,
+        "product_id": "prod-bistro-007",
+        "name_snapshot": "Espresso",
+        "quantity": 2,
+        "unit_price": "3.00",
+        "created_at": now(),
+    },
+    # O4 â€” Bistro cancelled (no items delivered)
+    {
+        "id": OI4a,
+        "order_id": O4,
+        "product_id": "prod-bistro-001",
+        "name_snapshot": "Duck Confit",
+        "quantity": 1,
+        "unit_price": "24.50",
+        "created_at": now(offset_days=-2),
+    },
+    {
+        "id": OI4b,
+        "order_id": O4,
+        "product_id": "prod-bistro-005",
+        "name_snapshot": "House Red Wine",
+        "quantity": 1,
+        "unit_price": "12.00",
+        "created_at": now(offset_days=-2),
+    },
+    # O5 â€” Pizza completed
+    {
+        "id": OI5a,
+        "order_id": O5,
+        "product_id": "prod-pizza-001",
+        "name_snapshot": "Margherita Pizza",
+        "quantity": 2,
+        "unit_price": "22.00",
+        "created_at": now(offset_days=-1, offset_hours=-2),
+    },
+    {
+        "id": OI5b,
+        "order_id": O5,
+        "product_id": "prod-pizza-005",
+        "name_snapshot": "Cola",
+        "quantity": 2,
+        "unit_price": "5.50",
+        "created_at": now(offset_days=-1, offset_hours=-2),
+    },
+    # O6 â€” Pizza in-progress
+    {
+        "id": OI6a,
+        "order_id": O6,
+        "product_id": "prod-pizza-002",
+        "name_snapshot": "Pepperoni Pizza",
+        "quantity": 2,
+        "unit_price": "19.00",
+        "created_at": now(offset_hours=-2),
+    },
+]
+
+PAYMENTS = [
+    # O1 â€” paid by card terminal
+    {
+        "id": PAY1,
+        "order_id": O1,
+        "provider": "TERMINAL",
+        "status": "COMPLETED",
+        "amount": "67.50",
+        "external_reference": None,
+        "created_at": now(offset_days=-1, offset_hours=-1),
+        "updated_at": now(offset_days=-1, offset_hours=-1),
+    },
+    # O2 â€” pending online payment initiated
+    {
+        "id": PAY2,
+        "order_id": O2,
+        "provider": "PRZELEWY24",
+        "status": "PENDING",
+        "amount": "43.00",
+        "external_reference": "P24-20260216-0042",
+        "created_at": now(offset_hours=-1),
+        "updated_at": now(offset_hours=-1),
+    },
+    # O4 â€” cancelled order, failed payment attempt
+    {
+        "id": PAY3,
+        "order_id": O4,
+        "provider": "PRZELEWY24",
+        "status": "FAILED",
+        "amount": "36.50",
+        "external_reference": "P24-20260215-0011",
+        "created_at": now(offset_days=-2),
+        "updated_at": now(offset_days=-2),
+    },
+    # O5 â€” Pizza paid cash
+    {
+        "id": PAY4,
+        "order_id": O5,
+        "provider": "CASH",
+        "status": "COMPLETED",
+        "amount": "55.00",
+        "external_reference": None,
+        "created_at": now(offset_days=-1, offset_hours=-1),
+        "updated_at": now(offset_days=-1, offset_hours=-1),
+    },
+    # O1 â€” partial refund (e.g., returned wine)
+    {
+        "id": PAY5,
+        "order_id": O1,
+        "provider": "TERMINAL",
+        "status": "REFUNDED",
+        "amount": "12.00",
+        "external_reference": None,
+        "created_at": now(offset_hours=-2),
+        "updated_at": now(offset_hours=-2),
+    },
+]
+
+
+# ---------------------------------------------------------------------------
+# Insert helpers
+# ---------------------------------------------------------------------------
+
+
+def insert(conn, table: str, rows: list[dict]) -> None:
+    if not rows:
+        return
+    conn.execute(
+        text(f"DELETE FROM {table} WHERE id IN :ids"), {"ids": tuple(str(r["id"]) for r in rows)}
+    )
+    for row in rows:
+        # Serialise any dict/list values to JSON strings for JSONB columns
+        cleaned = {k: (json.dumps(v) if isinstance(v, (dict, list)) else v) for k, v in row.items()}
+        placeholders = ", ".join(f":{k}" for k in cleaned)
+        columns = ", ".join(cleaned.keys())
+        conn.execute(text(f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"), cleaned)
+    print(f"  âœ“  {table}: {len(rows)} rows")  # noqa: T201
+
+
+def insert_no_id(conn, table: str, rows: list[dict]) -> None:
+    """For tables without a simple 'id' PK (e.g. user_tenants composite PK)."""
+    if not rows:
+        return
+    for row in rows:
+        cleaned = {k: (json.dumps(v) if isinstance(v, (dict, list)) else v) for k, v in row.items()}
+        placeholders = ", ".join(f":{k}" for k in cleaned)
+        columns = ", ".join(cleaned.keys())
+        conn.execute(
+            text(f"INSERT INTO {table} ({columns}) VALUES ({placeholders}) ON CONFLICT DO NOTHING"),
+            cleaned,
+        )
+    print(f"  âœ“  {table}: {len(rows)} rows")  # noqa: T201
+
+
+# ---------------------------------------------------------------------------
+# Main
+# ---------------------------------------------------------------------------
+
+
+def seed() -> None:
+    print("\nðŸŒ±  Seeding dev fixturesâ€¦\n")  # noqa: T201
+
+    with engine.begin() as conn:
+        # Disable FK checks temporarily so we can insert in any order
+        conn.execute(text("SET session_replication_role = 'replica'"))
+
+        try:
+            insert(conn, "tenants", TENANTS)
+            insert(conn, "users", USERS)
+            insert_no_id(conn, "user_tenants", USER_TENANTS)
+
+            # Venues inserted before canvases; active_layout_version_id set after
+            # Insert venues with NULL active layout first to avoid FK chicken-and-egg
+            venues_without_layout = [{**v, "active_layout_version_id": None} for v in VENUES]
+            insert(conn, "venues", venues_without_layout)
+            insert(conn, "floor_canvases", FLOOR_CANVASES)
+
+            # Now patch active_layout_version_id
+            for v in VENUES:
+                if v["active_layout_version_id"]:
+                    conn.execute(
+                        text("UPDATE venues SET active_layout_version_id = :lid WHERE id = :vid"),
+                        {"lid": v["active_layout_version_id"], "vid": v["id"]},
+                    )
+
+            insert(conn, "restaurant_tables", RESTAURANT_TABLES)
+            insert(conn, "orders", ORDERS)
+            insert(conn, "order_items", ORDER_ITEMS)
+            insert(conn, "payments", PAYMENTS)
+
+        finally:
+            conn.execute(text("SET session_replication_role = 'origin'"))
+
+    print("\nâœ…  Done! Here's a quick reference:\n")  # noqa: T201
+    print("  Tenant: The Grand Bistro   slug=grand-bistro   (ACTIVE)")  # noqa: T201
+    print("  Tenant: Pizza Palace       slug=pizza-palace   (ACTIVE)")  # noqa: T201
+    print("  Tenant: Corner CafÃ©        slug=corner-cafe    (SUSPENDED)\n")  # noqa: T201
+    print("  All user passwords: password123\n")  # noqa: T201
+    print("  Bistro logins:")  # noqa: T201
+    print("    owner@grand-bistro.dev   â€” owner,   active")  # noqa: T201
+    print("    manager@grand-bistro.dev â€” manager, active")  # noqa: T201
+    print("    waiter1@grand-bistro.dev â€” waiter,  active")  # noqa: T201
+    print("    waiter2@grand-bistro.dev â€” waiter,  INACTIVE")  # noqa: T201
+    print("    kitchen@grand-bistro.dev â€” kitchen, active")  # noqa: T201
+    print("  Pizza logins:")  # noqa: T201
+    print("    owner@pizza-palace.dev   â€” owner,   active")  # noqa: T201
+    print("    waiter@pizza-palace.dev  â€” waiter,  active")  # noqa: T201
+    print("    kitchen@pizza-palace.dev â€” kitchen, active")  # noqa: T201
+    print("  CafÃ© logins:")  # noqa: T201
+    print("    owner@corner-cafe.dev    â€” owner,   active (suspended tenant)\n")  # noqa: T201
+    print("  Order statuses covered: PENDING, IN_PROGRESS, COMPLETED, CANCELLED")  # noqa: T201
+    print("  Payment statuses covered: PENDING, COMPLETED, FAILED, REFUNDED")  # noqa: T201
+    print("  Payment providers covered: PRZELEWY24, CASH, TERMINAL\n")  # noqa: T201
+
+
+if __name__ == "__main__":
+    seed()
diff --git a/app/api/alembic/versions/20260211_add_venues_and_floor_canvases.py b/app/api/alembic/versions/20260211_add_venues_and_floor_canvases.py
index 7600752..fb7e138 100644
--- a/app/api/alembic/versions/20260211_add_venues_and_floor_canvases.py
+++ b/app/api/alembic/versions/20260211_add_venues_and_floor_canvases.py
@@ -14,7 +14,7 @@ from sqlalchemy.dialects import postgresql
 
 
 revision: str = "2a8f3c5d7e9b"
-down_revision: Union[str, None] = "165824d5181d"
+down_revision: Union[str, None] = "b2c3d4e5f6a1"
 branch_labels: Union[str, Sequence[str], None] = None
 depends_on: Union[str, Sequence[str], None] = None
 
diff --git a/app/api/alembic/versions/20260212_235848_new_fields.py b/app/api/alembic/versions/20260212_235848_new_fields.py
deleted file mode 100644
index dfdf9d5..0000000
--- a/app/api/alembic/versions/20260212_235848_new_fields.py
+++ /dev/null
@@ -1,31 +0,0 @@
-"""new_fields
-
-Revision ID: a82e1472ceea
-Revises: 2a8f3c5d7e9b
-Create Date: 2026-02-12 23:58:48.037199
-
-"""
-
-from typing import Sequence, Union
-
-from alembic import op
-import sqlalchemy as sa
-
-
-# revision identifiers, used by Alembic.
-revision: str = "a82e1472ceea"
-down_revision: Union[str, None] = "2a8f3c5d7e9b"
-branch_labels: Union[str, Sequence[str], None] = None
-depends_on: Union[str, Sequence[str], None] = None
-
-
-def upgrade() -> None:
-    # ### commands auto generated by Alembic - please adjust! ###
-    pass
-    # ### end Alembic commands ###
-
-
-def downgrade() -> None:
-    # ### commands auto generated by Alembic - please adjust! ###
-    pass
-    # ### end Alembic commands ###
diff --git a/app/api/alembic/versions/20260217_merge_heads.py b/app/api/alembic/versions/20260217_merge_heads.py
index 13c70a7..38450d4 100644
--- a/app/api/alembic/versions/20260217_merge_heads.py
+++ b/app/api/alembic/versions/20260217_merge_heads.py
@@ -1,7 +1,7 @@
 """merge_heads
 
 Revision ID: c03e4694e1bd
-Revises: a82e1472ceea, b2c3d4e5f6a1
+Revises: c3d4e5f6a7b8, f2a3b4c5d6e7
 Create Date: 2026-02-17
 
 """
@@ -12,7 +12,7 @@ from alembic import op
 
 
 revision: str = "c03e4694e1bd"
-down_revision: Union[str, tuple[str, ...], None] = ("a82e1472ceea", "b2c3d4e5f6a1")
+down_revision: Union[str, tuple[str, ...], None] = ("c3d4e5f6a7b8", "f2a3b4c5d6e7")
 branch_labels: Union[str, Sequence[str], None] = None
 depends_on: Union[str, Sequence[str], None] = None
 
diff --git a/app/api/alembic/versions/20260217_move_active_layout_to_tenants_and_remove_venues.py b/app/api/alembic/versions/20260217_move_active_layout_to_tenants_and_remove_venues.py
new file mode 100644
index 0000000..b3756ef
--- /dev/null
+++ b/app/api/alembic/versions/20260217_move_active_layout_to_tenants_and_remove_venues.py
@@ -0,0 +1,147 @@
+"""move_active_layout_to_tenants_and_remove_venues
+
+Revision ID: c3d4e5f6a7b8
+Revises: 2a8f3c5d7e9b
+Create Date: 2026-02-17
+
+"""
+
+from typing import Sequence, Union
+
+from alembic import op
+import sqlalchemy as sa
+from sqlalchemy.dialects import postgresql
+
+
+revision: str = "c3d4e5f6a7b8"
+down_revision: Union[str, None] = "2a8f3c5d7e9b"
+branch_labels: Union[str, Sequence[str], None] = None
+depends_on: Union[str, Sequence[str], None] = None
+
+
+def upgrade() -> None:
+    op.add_column(
+        "tenants",
+        sa.Column("active_layout_version_id", postgresql.UUID(as_uuid=True), nullable=True),
+    )
+
+    op.execute("""
+        UPDATE tenants
+        SET active_layout_version_id = (
+            SELECT active_layout_version_id
+            FROM venues
+            WHERE venues.tenant_id = tenants.id
+            LIMIT 1
+        )
+    """)
+
+    op.add_column(
+        "floor_canvases",
+        sa.Column("tenant_id", postgresql.UUID(as_uuid=True), nullable=True),
+    )
+
+    op.execute("""
+        UPDATE floor_canvases
+        SET tenant_id = (
+            SELECT tenant_id
+            FROM venues
+            WHERE venues.id = floor_canvases.venue_id
+        )
+    """)
+
+    op.alter_column("floor_canvases", "tenant_id", nullable=False)
+
+    op.drop_constraint("floor_canvases_venue_id_fkey", "floor_canvases", type_="foreignkey")
+    op.drop_index("idx_floor_canvases_venue_id", table_name="floor_canvases")
+    op.drop_column("floor_canvases", "venue_id")
+
+    op.create_foreign_key(
+        "fk_floor_canvases_tenant_id",
+        "floor_canvases",
+        "tenants",
+        ["tenant_id"],
+        ["id"],
+        ondelete="CASCADE",
+    )
+    op.create_index("idx_floor_canvases_tenant_id", "floor_canvases", ["tenant_id"], unique=False)
+
+    op.create_foreign_key(
+        "fk_tenants_active_layout_version_id",
+        "tenants",
+        "floor_canvases",
+        ["active_layout_version_id"],
+        ["id"],
+        ondelete="SET NULL",
+    )
+
+    op.drop_constraint("fk_venues_active_layout_version_id", "venues", type_="foreignkey")
+    op.drop_index("idx_venues_tenant_id", table_name="venues")
+    op.drop_table("venues")
+
+
+def downgrade() -> None:
+    op.create_table(
+        "venues",
+        sa.Column("id", postgresql.UUID(as_uuid=True), nullable=False),
+        sa.Column("tenant_id", postgresql.UUID(as_uuid=True), nullable=False),
+        sa.Column("name", sa.String(length=255), nullable=False),
+        sa.Column("active_layout_version_id", postgresql.UUID(as_uuid=True), nullable=True),
+        sa.Column(
+            "created_at",
+            sa.DateTime(timezone=True),
+            server_default=sa.text("now()"),
+            nullable=False,
+        ),
+        sa.Column(
+            "updated_at",
+            sa.DateTime(timezone=True),
+            server_default=sa.text("now()"),
+            nullable=False,
+        ),
+        sa.ForeignKeyConstraint(["tenant_id"], ["tenants.id"], ondelete="CASCADE"),
+        sa.PrimaryKeyConstraint("id"),
+    )
+    op.create_index("idx_venues_tenant_id", "venues", ["tenant_id"], unique=False)
+
+    op.drop_constraint("fk_tenants_active_layout_version_id", "tenants", type_="foreignkey")
+    op.drop_column("tenants", "active_layout_version_id")
+
+    op.add_column(
+        "floor_canvases",
+        sa.Column("venue_id", postgresql.UUID(as_uuid=True), nullable=True),
+    )
+
+    op.execute("""
+        UPDATE floor_canvases
+        SET venue_id = (
+            SELECT id
+            FROM venues
+            WHERE venues.tenant_id = floor_canvases.tenant_id
+            LIMIT 1
+        )
+    """)
+
+    op.alter_column("floor_canvases", "venue_id", nullable=False)
+
+    op.drop_constraint("fk_floor_canvases_tenant_id", "floor_canvases", type_="foreignkey")
+    op.drop_index("idx_floor_canvases_tenant_id", table_name="floor_canvases")
+    op.drop_column("floor_canvases", "tenant_id")
+
+    op.create_foreign_key(
+        "floor_canvases_venue_id_fkey",
+        "floor_canvases",
+        "venues",
+        ["venue_id"],
+        ["id"],
+        ondelete="CASCADE",
+    )
+    op.create_index("idx_floor_canvases_venue_id", "floor_canvases", ["venue_id"], unique=False)
+
+    op.create_foreign_key(
+        "fk_venues_active_layout_version_id",
+        "venues",
+        "floor_canvases",
+        ["active_layout_version_id"],
+        ["id"],
+        ondelete="SET NULL",
+    )
diff --git a/app/api/api/__init__.py b/app/api/api/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/app/api/api/v1/__init__.py b/app/api/api/v1/__init__.py
deleted file mode 100644
index 258d509..0000000
--- a/app/api/api/v1/__init__.py
+++ /dev/null
@@ -1,3 +0,0 @@
-from api.v1 import dto
-
-__all__ = ["dto"]
diff --git a/app/api/api/v1/dto/__init__.py b/app/api/api/v1/dto/__init__.py
deleted file mode 100644
index a1643ac..0000000
--- a/app/api/api/v1/dto/__init__.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from api.v1.dto import auth, common, menus, orders, payments, restaurants, tenants, users, venues
-
-__all__ = [
-    "auth",
-    "common",
-    "menus",
-    "orders",
-    "payments",
-    "restaurants",
-    "tenants",
-    "users",
-    "venues",
-]
diff --git a/app/api/api/v1/dto/menus/__init__.py b/app/api/api/v1/dto/menus/__init__.py
deleted file mode 100644
index b8d3bbf..0000000
--- a/app/api/api/v1/dto/menus/__init__.py
+++ /dev/null
@@ -1,9 +0,0 @@
-from api.v1.dto.menus.requests import CreateMenuItemDTO, CreateModifierDTO
-from api.v1.dto.menus.responses import MenuItemDTO, ModifierDTO
-
-__all__ = [
-    "CreateMenuItemDTO",
-    "CreateModifierDTO",
-    "MenuItemDTO",
-    "ModifierDTO",
-]
diff --git a/app/api/api/v1/dto/orders/__init__.py b/app/api/api/v1/dto/orders/__init__.py
deleted file mode 100644
index 16f315f..0000000
--- a/app/api/api/v1/dto/orders/__init__.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from api.v1.dto.orders.requests import CreateOrderDTO, CreateOrderItemDTO, UpdateOrderDTO
-from api.v1.dto.orders.responses import OrderItemResponseDTO, OrderResponseDTO
-
-__all__ = [
-    "CreateOrderDTO",
-    "CreateOrderItemDTO",
-    "OrderItemResponseDTO",
-    "OrderResponseDTO",
-    "UpdateOrderDTO",
-]
diff --git a/app/api/api/v1/dto/restaurants/__init__.py b/app/api/api/v1/dto/restaurants/__init__.py
deleted file mode 100644
index e99b459..0000000
--- a/app/api/api/v1/dto/restaurants/__init__.py
+++ /dev/null
@@ -1,8 +0,0 @@
-from api.v1.dto.restaurants.requests import CreateRestaurantTableDTO, UpdateRestaurantTableDTO
-from api.v1.dto.restaurants.responses import RestaurantTableResponseDTO
-
-__all__ = [
-    "CreateRestaurantTableDTO",
-    "RestaurantTableResponseDTO",
-    "UpdateRestaurantTableDTO",
-]
diff --git a/app/api/api/v1/dto/tenants/__init__.py b/app/api/api/v1/dto/tenants/__init__.py
deleted file mode 100644
index 706f030..0000000
--- a/app/api/api/v1/dto/tenants/__init__.py
+++ /dev/null
@@ -1,8 +0,0 @@
-from api.v1.dto.tenants.requests import CreateTenantDTO, UpdateTenantDTO
-from api.v1.dto.tenants.responses import TenantResponseDTO
-
-__all__ = [
-    "CreateTenantDTO",
-    "TenantResponseDTO",
-    "UpdateTenantDTO",
-]
diff --git a/app/api/api/v1/dto/tenants/responses.py b/app/api/api/v1/dto/tenants/responses.py
deleted file mode 100644
index 14736d1..0000000
--- a/app/api/api/v1/dto/tenants/responses.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from datetime import datetime
-
-from pydantic import Field
-
-from api.v1.dto.common import BaseDTO, EntityId, TenantStatus
-
-
-class TenantResponseDTO(BaseDTO):
-    id: EntityId = Field(..., description="Unique tenant identifier")
-    name: str = Field(..., description="Tenant name")
-    slug: str = Field(..., description="URL-friendly tenant identifier")
-    status: TenantStatus = Field(..., description="Tenant status")
-    created_at: datetime = Field(..., description="Timestamp when tenant was created")
diff --git a/app/api/core/dto/v1/__init__.py b/app/api/core/dto/v1/__init__.py
new file mode 100644
index 0000000..28b77c4
--- /dev/null
+++ b/app/api/core/dto/v1/__init__.py
@@ -0,0 +1,41 @@
+from core.dto.v1 import (
+    auth,
+    common,
+    floor_canvases,
+    menus,
+    orders,
+    payments,
+    restaurants,
+    tenants,
+    users,
+)
+from core.dto.v1.floor_canvases import (
+    CreateFloorCanvasDTO,
+    FloorCanvasResponseDTO,
+    UpdateFloorCanvasDTO,
+)
+from core.dto.v1.tenants import (
+    CreateTenantDTO,
+    TenantResponseDTO,
+    TenantSummaryResponseDTO,
+    UpdateTenantDTO,
+)
+
+__all__ = [
+    "CreateFloorCanvasDTO",
+    "CreateTenantDTO",
+    "FloorCanvasResponseDTO",
+    "TenantResponseDTO",
+    "TenantSummaryResponseDTO",
+    "UpdateFloorCanvasDTO",
+    "UpdateTenantDTO",
+    "auth",
+    "common",
+    "floor_canvases",
+    "menus",
+    "orders",
+    "payments",
+    "restaurants",
+    "tenants",
+    "users",
+]
diff --git a/app/api/api/v1/dto/auth/__init__.py b/app/api/core/dto/v1/auth/__init__.py
similarity index 92%
rename from app/api/api/v1/dto/auth/__init__.py
rename to app/api/core/dto/v1/auth/__init__.py
index 6955d3a..904024f 100644
--- a/app/api/api/v1/dto/auth/__init__.py
+++ b/app/api/core/dto/v1/auth/__init__.py
@@ -1,6 +1,6 @@
 from pydantic import EmailStr, Field
 
-from api.v1.dto.common import BaseDTO
+from core.dto.v1.common import BaseDTO
 
 
 class RegisterDTO(BaseDTO):
@@ -12,7 +12,6 @@ class RegisterDTO(BaseDTO):
 class RegisterCreatedData(BaseDTO):
     user_id: str = Field(..., description="Created user ID")
     email: EmailStr = Field(..., description="User email")
-    account_type: str = Field(..., description="Account type")
     tenant_id: str = Field(..., description="Created tenant ID")
     tenant_name: str = Field(..., description="Tenant name")
     tenant_slug: str = Field(..., description="Tenant slug")
diff --git a/app/api/api/v1/dto/common/__init__.py b/app/api/core/dto/v1/common/__init__.py
similarity index 64%
rename from app/api/api/v1/dto/common/__init__.py
rename to app/api/core/dto/v1/common/__init__.py
index e706047..30cec2a 100644
--- a/app/api/api/v1/dto/common/__init__.py
+++ b/app/api/core/dto/v1/common/__init__.py
@@ -1,12 +1,12 @@
-from api.v1.dto.common.base import BaseDTO
-from api.v1.dto.common.enums import (
+from core.dto.v1.common.base import BaseDTO
+from core.dto.v1.common.enums import (
     AccountType,
     OrderStatus,
     PaymentProvider,
     PaymentStatus,
     TenantStatus,
 )
-from api.v1.dto.common.types import CurrencyCode, EntityId
+from core.dto.v1.common.types import CurrencyCode, EntityId
 
 __all__ = [
     "AccountType",
diff --git a/app/api/api/v1/dto/common/base.py b/app/api/core/dto/v1/common/base.py
similarity index 100%
rename from app/api/api/v1/dto/common/base.py
rename to app/api/core/dto/v1/common/base.py
diff --git a/app/api/api/v1/dto/common/enums.py b/app/api/core/dto/v1/common/enums.py
similarity index 100%
rename from app/api/api/v1/dto/common/enums.py
rename to app/api/core/dto/v1/common/enums.py
diff --git a/app/api/api/v1/dto/common/types.py b/app/api/core/dto/v1/common/types.py
similarity index 100%
rename from app/api/api/v1/dto/common/types.py
rename to app/api/core/dto/v1/common/types.py
diff --git a/app/api/api/v1/dto/venues/__init__.py b/app/api/core/dto/v1/floor_canvases/__init__.py
similarity index 69%
rename from app/api/api/v1/dto/venues/__init__.py
rename to app/api/core/dto/v1/floor_canvases/__init__.py
index 557dced..39192c4 100644
--- a/app/api/api/v1/dto/venues/__init__.py
+++ b/app/api/core/dto/v1/floor_canvases/__init__.py
@@ -1,6 +1,5 @@
-from api.v1.dto.venues.requests import (
+from core.dto.v1.floor_canvases.requests import (
     CreateFloorCanvasDTO,
-    CreateVenueDTO,
     FloorBarElementDTO,
     FloorElementDTO,
     FloorEntranceElementDTO,
@@ -9,18 +8,14 @@ from api.v1.dto.venues.requests import (
     FloorWallElementDTO,
     FloorZoneElementDTO,
     UpdateFloorCanvasDTO,
-    UpdateVenueDTO,
 )
-from api.v1.dto.venues.responses import (
+from core.dto.v1.floor_canvases.responses import (
     FloorCanvasResponseDTO,
     FloorElementResponseDTO,
-    VenueResponseDTO,
-    VenueSummaryResponseDTO,
 )
 
 __all__ = [
     "CreateFloorCanvasDTO",
-    "CreateVenueDTO",
     "FloorBarElementDTO",
     "FloorCanvasResponseDTO",
     "FloorElementDTO",
@@ -31,7 +26,4 @@ __all__ = [
     "FloorWallElementDTO",
     "FloorZoneElementDTO",
     "UpdateFloorCanvasDTO",
-    "UpdateVenueDTO",
-    "VenueResponseDTO",
-    "VenueSummaryResponseDTO",
 ]
diff --git a/app/api/api/v1/dto/venues/requests.py b/app/api/core/dto/v1/floor_canvases/requests.py
similarity index 86%
rename from app/api/api/v1/dto/venues/requests.py
rename to app/api/core/dto/v1/floor_canvases/requests.py
index 6d86824..c848ee5 100644
--- a/app/api/api/v1/dto/venues/requests.py
+++ b/app/api/core/dto/v1/floor_canvases/requests.py
@@ -2,7 +2,7 @@ from typing import Literal
 
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO, EntityId
+from core.dto.v1.common import BaseDTO
 
 
 class FloorElementBaseDTO(BaseDTO):
@@ -73,14 +73,3 @@ class UpdateFloorCanvasDTO(BaseDTO):
     width: int | None = Field(None, gt=0, description="Canvas width in pixels")
     height: int | None = Field(None, gt=0, description="Canvas height in pixels")
     elements: list[FloorElementDTO] | None = Field(None, description="Floor elements")
-
-
-class CreateVenueDTO(BaseDTO):
-    name: str = Field(..., min_length=1, max_length=255, description="Venue name")
-
-
-class UpdateVenueDTO(BaseDTO):
-    name: str | None = Field(None, min_length=1, max_length=255, description="Venue name")
-    active_layout_version_id: EntityId | None = Field(
-        None, alias="activeLayoutVersionId", description="Active floor canvas id"
-    )
diff --git a/app/api/api/v1/dto/venues/responses.py b/app/api/core/dto/v1/floor_canvases/responses.py
similarity index 63%
rename from app/api/api/v1/dto/venues/responses.py
rename to app/api/core/dto/v1/floor_canvases/responses.py
index a07acc0..1dd605d 100644
--- a/app/api/api/v1/dto/venues/responses.py
+++ b/app/api/core/dto/v1/floor_canvases/responses.py
@@ -3,7 +3,7 @@ from typing import Literal
 
 from pydantic import ConfigDict, Field
 
-from api.v1.dto.common import BaseDTO, EntityId
+from core.dto.v1.common import BaseDTO, EntityId
 
 
 class FloorElementBaseResponseDTO(BaseDTO):
@@ -66,8 +66,8 @@ FloorElementResponseDTO = (
 
 class FloorCanvasResponseDTO(BaseDTO):
     id: EntityId = Field(..., description="Canvas identifier")
-    venue_id: EntityId = Field(
-        ..., alias="venueId", serialization_alias="venueId", description="Venue identifier"
+    tenant_id: EntityId = Field(
+        ..., alias="tenantId", serialization_alias="tenantId", description="Tenant identifier"
     )
     name: str = Field(..., description="Canvas name")
     width: int = Field(..., description="Canvas width in pixels")
@@ -78,39 +78,3 @@ class FloorCanvasResponseDTO(BaseDTO):
     updated_at: datetime = Field(..., alias="updatedAt", serialization_alias="updatedAt")
 
     model_config = ConfigDict(populate_by_name=True)
-
-
-class VenueResponseDTO(BaseDTO):
-    id: EntityId = Field(..., description="Venue identifier")
-    tenant_id: EntityId = Field(
-        ..., alias="tenantId", serialization_alias="tenantId", description="Tenant identifier"
-    )
-    name: str = Field(..., description="Venue name")
-    active_layout_version_id: EntityId | None = Field(
-        None, alias="activeLayoutVersionId", serialization_alias="activeLayoutVersionId"
-    )
-    floor_canvases: list[FloorCanvasResponseDTO] = Field(
-        ..., alias="floorCanvases", serialization_alias="floorCanvases"
-    )
-    created_at: datetime = Field(..., alias="createdAt", serialization_alias="createdAt")
-    updated_at: datetime = Field(..., alias="updatedAt", serialization_alias="updatedAt")
-
-    model_config = ConfigDict(populate_by_name=True)
-
-
-class VenueSummaryResponseDTO(BaseDTO):
-    id: EntityId = Field(..., description="Venue identifier")
-    tenant_id: EntityId = Field(
-        ..., alias="tenantId", serialization_alias="tenantId", description="Tenant identifier"
-    )
-    name: str = Field(..., description="Venue name")
-    active_layout_version_id: EntityId | None = Field(
-        None, alias="activeLayoutVersionId", serialization_alias="activeLayoutVersionId"
-    )
-    floor_canvas_count: int = Field(
-        ..., alias="floorCanvasCount", serialization_alias="floorCanvasCount"
-    )
-    created_at: datetime = Field(..., alias="createdAt", serialization_alias="createdAt")
-    updated_at: datetime = Field(..., alias="updatedAt", serialization_alias="updatedAt")
-
-    model_config = ConfigDict(populate_by_name=True)
diff --git a/app/api/core/dto/v1/menus/__init__.py b/app/api/core/dto/v1/menus/__init__.py
new file mode 100644
index 0000000..2ee553d
--- /dev/null
+++ b/app/api/core/dto/v1/menus/__init__.py
@@ -0,0 +1,9 @@
+from core.dto.v1.menus.requests import CreateMenuItemDTO, CreateModifierDTO
+from core.dto.v1.menus.responses import MenuItemDTO, ModifierDTO
+
+__all__ = [
+    "CreateMenuItemDTO",
+    "CreateModifierDTO",
+    "MenuItemDTO",
+    "ModifierDTO",
+]
diff --git a/app/api/api/v1/dto/menus/requests.py b/app/api/core/dto/v1/menus/requests.py
similarity index 94%
rename from app/api/api/v1/dto/menus/requests.py
rename to app/api/core/dto/v1/menus/requests.py
index f79dbc2..42109c6 100644
--- a/app/api/api/v1/dto/menus/requests.py
+++ b/app/api/core/dto/v1/menus/requests.py
@@ -2,7 +2,7 @@ from decimal import Decimal
 
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO
+from core.dto.v1.common import BaseDTO
 
 
 class CreateModifierDTO(BaseDTO):
diff --git a/app/api/api/v1/dto/menus/responses.py b/app/api/core/dto/v1/menus/responses.py
similarity index 95%
rename from app/api/api/v1/dto/menus/responses.py
rename to app/api/core/dto/v1/menus/responses.py
index 861b1c1..308616f 100644
--- a/app/api/api/v1/dto/menus/responses.py
+++ b/app/api/core/dto/v1/menus/responses.py
@@ -2,7 +2,7 @@ from decimal import Decimal
 
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO
+from core.dto.v1.common import BaseDTO
 
 
 class ModifierDTO(BaseDTO):
diff --git a/app/api/core/dto/v1/orders/__init__.py b/app/api/core/dto/v1/orders/__init__.py
new file mode 100644
index 0000000..7f3c60b
--- /dev/null
+++ b/app/api/core/dto/v1/orders/__init__.py
@@ -0,0 +1,10 @@
+from core.dto.v1.orders.requests import CreateOrderDTO, CreateOrderItemDTO, UpdateOrderDTO
+from core.dto.v1.orders.responses import OrderItemResponseDTO, OrderResponseDTO
+
+__all__ = [
+    "CreateOrderDTO",
+    "CreateOrderItemDTO",
+    "OrderItemResponseDTO",
+    "OrderResponseDTO",
+    "UpdateOrderDTO",
+]
diff --git a/app/api/api/v1/dto/orders/requests.py b/app/api/core/dto/v1/orders/requests.py
similarity index 91%
rename from app/api/api/v1/dto/orders/requests.py
rename to app/api/core/dto/v1/orders/requests.py
index b9ff0b1..ad8c03e 100644
--- a/app/api/api/v1/dto/orders/requests.py
+++ b/app/api/core/dto/v1/orders/requests.py
@@ -2,7 +2,7 @@ from decimal import Decimal
 
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO, CurrencyCode, EntityId, OrderStatus
+from core.dto.v1.common import BaseDTO, CurrencyCode, EntityId, OrderStatus
 
 
 class CreateOrderItemDTO(BaseDTO):
diff --git a/app/api/api/v1/dto/orders/responses.py b/app/api/core/dto/v1/orders/responses.py
similarity index 93%
rename from app/api/api/v1/dto/orders/responses.py
rename to app/api/core/dto/v1/orders/responses.py
index 7e542ca..6353cfd 100644
--- a/app/api/api/v1/dto/orders/responses.py
+++ b/app/api/core/dto/v1/orders/responses.py
@@ -3,7 +3,7 @@ from decimal import Decimal
 
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO, CurrencyCode, EntityId, OrderStatus
+from core.dto.v1.common import BaseDTO, CurrencyCode, EntityId, OrderStatus
 
 
 class OrderItemResponseDTO(BaseDTO):
diff --git a/app/api/api/v1/dto/payments/__init__.py b/app/api/core/dto/v1/payments/__init__.py
similarity index 63%
rename from app/api/api/v1/dto/payments/__init__.py
rename to app/api/core/dto/v1/payments/__init__.py
index 350aa84..2460626 100644
--- a/app/api/api/v1/dto/payments/__init__.py
+++ b/app/api/core/dto/v1/payments/__init__.py
@@ -1,9 +1,9 @@
-from api.v1.dto.payments.requests import (
+from core.dto.v1.payments.requests import (
     CreatePaymentDTO,
     UpdateP24ConfigDTO,
     UpdatePaymentDTO,
 )
-from api.v1.dto.payments.responses import PaymentResponseDTO
+from core.dto.v1.payments.responses import PaymentResponseDTO
 
 __all__ = [
     "CreatePaymentDTO",
diff --git a/app/api/api/v1/dto/payments/requests.py b/app/api/core/dto/v1/payments/requests.py
similarity index 92%
rename from app/api/api/v1/dto/payments/requests.py
rename to app/api/core/dto/v1/payments/requests.py
index 8c098d6..40b1473 100644
--- a/app/api/api/v1/dto/payments/requests.py
+++ b/app/api/core/dto/v1/payments/requests.py
@@ -2,7 +2,7 @@ from decimal import Decimal
 
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO, EntityId, PaymentProvider, PaymentStatus
+from core.dto.v1.common import BaseDTO, EntityId, PaymentProvider, PaymentStatus
 
 
 class CreatePaymentDTO(BaseDTO):
diff --git a/app/api/api/v1/dto/payments/responses.py b/app/api/core/dto/v1/payments/responses.py
similarity index 90%
rename from app/api/api/v1/dto/payments/responses.py
rename to app/api/core/dto/v1/payments/responses.py
index ae3a810..df696c4 100644
--- a/app/api/api/v1/dto/payments/responses.py
+++ b/app/api/core/dto/v1/payments/responses.py
@@ -3,7 +3,7 @@ from decimal import Decimal
 
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO, EntityId, PaymentProvider, PaymentStatus
+from core.dto.v1.common import BaseDTO, EntityId, PaymentProvider, PaymentStatus
 
 
 class PaymentResponseDTO(BaseDTO):
diff --git a/app/api/core/dto/v1/restaurants/__init__.py b/app/api/core/dto/v1/restaurants/__init__.py
new file mode 100644
index 0000000..567366f
--- /dev/null
+++ b/app/api/core/dto/v1/restaurants/__init__.py
@@ -0,0 +1,8 @@
+from core.dto.v1.restaurants.requests import CreateRestaurantTableDTO, UpdateRestaurantTableDTO
+from core.dto.v1.restaurants.responses import RestaurantTableResponseDTO
+
+__all__ = [
+    "CreateRestaurantTableDTO",
+    "RestaurantTableResponseDTO",
+    "UpdateRestaurantTableDTO",
+]
diff --git a/app/api/api/v1/dto/restaurants/requests.py b/app/api/core/dto/v1/restaurants/requests.py
similarity index 94%
rename from app/api/api/v1/dto/restaurants/requests.py
rename to app/api/core/dto/v1/restaurants/requests.py
index f0c3b78..ab93ca1 100644
--- a/app/api/api/v1/dto/restaurants/requests.py
+++ b/app/api/core/dto/v1/restaurants/requests.py
@@ -1,6 +1,6 @@
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO
+from core.dto.v1.common import BaseDTO
 
 
 class CreateRestaurantTableDTO(BaseDTO):
diff --git a/app/api/api/v1/dto/restaurants/responses.py b/app/api/core/dto/v1/restaurants/responses.py
similarity index 91%
rename from app/api/api/v1/dto/restaurants/responses.py
rename to app/api/core/dto/v1/restaurants/responses.py
index bd4d88b..d01dd9e 100644
--- a/app/api/api/v1/dto/restaurants/responses.py
+++ b/app/api/core/dto/v1/restaurants/responses.py
@@ -2,7 +2,7 @@ from datetime import datetime
 
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO, EntityId
+from core.dto.v1.common import BaseDTO, EntityId
 
 
 class RestaurantTableResponseDTO(BaseDTO):
diff --git a/app/api/core/dto/v1/tenants/__init__.py b/app/api/core/dto/v1/tenants/__init__.py
new file mode 100644
index 0000000..5074695
--- /dev/null
+++ b/app/api/core/dto/v1/tenants/__init__.py
@@ -0,0 +1,9 @@
+from core.dto.v1.tenants.requests import CreateTenantDTO, UpdateTenantDTO
+from core.dto.v1.tenants.responses import TenantResponseDTO, TenantSummaryResponseDTO
+
+__all__ = [
+    "CreateTenantDTO",
+    "TenantResponseDTO",
+    "TenantSummaryResponseDTO",
+    "UpdateTenantDTO",
+]
diff --git a/app/api/api/v1/dto/tenants/requests.py b/app/api/core/dto/v1/tenants/requests.py
similarity index 79%
rename from app/api/api/v1/dto/tenants/requests.py
rename to app/api/core/dto/v1/tenants/requests.py
index 6651a34..619c479 100644
--- a/app/api/api/v1/dto/tenants/requests.py
+++ b/app/api/core/dto/v1/tenants/requests.py
@@ -1,6 +1,6 @@
 from pydantic import Field
 
-from api.v1.dto.common import BaseDTO, TenantStatus
+from core.dto.v1.common import BaseDTO, EntityId, TenantStatus
 
 
 class CreateTenantDTO(BaseDTO):
@@ -25,3 +25,6 @@ class UpdateTenantDTO(BaseDTO):
         description="URL-friendly tenant identifier",
     )
     status: TenantStatus | None = Field(None, description="Tenant status")
+    active_layout_version_id: EntityId | None = Field(
+        None, alias="activeLayoutVersionId", description="Active floor canvas id"
+    )
diff --git a/app/api/core/dto/v1/tenants/responses.py b/app/api/core/dto/v1/tenants/responses.py
new file mode 100644
index 0000000..66fe721
--- /dev/null
+++ b/app/api/core/dto/v1/tenants/responses.py
@@ -0,0 +1,36 @@
+from datetime import datetime
+
+from pydantic import Field
+
+from core.dto.v1.common import BaseDTO, EntityId, TenantStatus
+from core.dto.v1.floor_canvases import FloorCanvasResponseDTO
+
+
+class TenantResponseDTO(BaseDTO):
+    id: EntityId = Field(..., description="Unique tenant identifier")
+    name: str = Field(..., description="Tenant name")
+    slug: str = Field(..., description="URL-friendly tenant identifier")
+    status: TenantStatus = Field(..., description="Tenant status")
+    active_layout_version_id: EntityId | None = Field(
+        None, alias="activeLayoutVersionId", serialization_alias="activeLayoutVersionId"
+    )
+    floor_canvases: list[FloorCanvasResponseDTO] = Field(
+        default_factory=list,
+        alias="floorCanvases",
+        serialization_alias="floorCanvases",
+    )
+    created_at: datetime = Field(..., description="Timestamp when tenant was created")
+
+
+class TenantSummaryResponseDTO(BaseDTO):
+    id: EntityId = Field(..., description="Unique tenant identifier")
+    name: str = Field(..., description="Tenant name")
+    slug: str = Field(..., description="URL-friendly tenant identifier")
+    status: TenantStatus = Field(..., description="Tenant status")
+    active_layout_version_id: EntityId | None = Field(
+        None, alias="activeLayoutVersionId", serialization_alias="activeLayoutVersionId"
+    )
+    floor_canvas_count: int = Field(
+        ..., alias="floorCanvasCount", serialization_alias="floorCanvasCount"
+    )
+    created_at: datetime = Field(..., description="Timestamp when tenant was created")
diff --git a/app/api/api/v1/dto/users/__init__.py b/app/api/core/dto/v1/users/__init__.py
similarity index 66%
rename from app/api/api/v1/dto/users/__init__.py
rename to app/api/core/dto/v1/users/__init__.py
index fd255df..9a9b375 100644
--- a/app/api/api/v1/dto/users/__init__.py
+++ b/app/api/core/dto/v1/users/__init__.py
@@ -1,10 +1,10 @@
-from api.v1.dto.users.requests import (
+from core.dto.v1.users.requests import (
     CreateUserDTO,
     CreateUserTenantDTO,
     UpdateUserDTO,
     UserLoginDTO,
 )
-from api.v1.dto.users.responses import UserResponseDTO, UserTenantResponseDTO
+from core.dto.v1.users.responses import UserResponseDTO, UserTenantResponseDTO
 
 __all__ = [
     "CreateUserDTO",
diff --git a/app/api/api/v1/dto/users/requests.py b/app/api/core/dto/v1/users/requests.py
similarity index 95%
rename from app/api/api/v1/dto/users/requests.py
rename to app/api/core/dto/v1/users/requests.py
index 7ebf3db..8e6a664 100644
--- a/app/api/api/v1/dto/users/requests.py
+++ b/app/api/core/dto/v1/users/requests.py
@@ -1,6 +1,6 @@
 from pydantic import EmailStr, Field
 
-from api.v1.dto.common import AccountType, BaseDTO, EntityId
+from core.dto.v1.common import AccountType, BaseDTO, EntityId
 
 
 class CreateUserDTO(BaseDTO):
diff --git a/app/api/api/v1/dto/users/responses.py b/app/api/core/dto/v1/users/responses.py
similarity index 92%
rename from app/api/api/v1/dto/users/responses.py
rename to app/api/core/dto/v1/users/responses.py
index 62f6eff..b910a41 100644
--- a/app/api/api/v1/dto/users/responses.py
+++ b/app/api/core/dto/v1/users/responses.py
@@ -2,7 +2,7 @@ from datetime import datetime
 
 from pydantic import EmailStr, Field
 
-from api.v1.dto.common import AccountType, BaseDTO, EntityId
+from core.dto.v1.common import AccountType, BaseDTO, EntityId
 
 
 class UserResponseDTO(BaseDTO):
diff --git a/app/api/core/exceptions/handlers.py b/app/api/core/exceptions/handlers.py
index c8e0c92..de8c435 100644
--- a/app/api/core/exceptions/handlers.py
+++ b/app/api/core/exceptions/handlers.py
@@ -2,7 +2,7 @@ from fastapi import FastAPI, Request, status
 from fastapi.responses import JSONResponse
 
 from core.exceptions import BaseHTTPException
-from core.foundation.http.schemas import ErrorResponse
+from core.foundation.http.responses import ErrorResponse
 from core.foundation.infra.config import Settings
 
 
diff --git a/app/api/core/exceptions/http.py b/app/api/core/exceptions/http.py
index e9c45e9..8176411 100644
--- a/app/api/core/exceptions/http.py
+++ b/app/api/core/exceptions/http.py
@@ -1,7 +1,7 @@
 from fastapi import HTTPException, status
 from fastapi.responses import JSONResponse
 
-from core.foundation.http.schemas import ErrorResponse
+from core.foundation.http.responses import ErrorResponse
 
 
 class BaseHTTPException(HTTPException):
diff --git a/app/api/core/foundation/dependencies.py b/app/api/core/foundation/dependencies.py
index 21d8399..e9f30da 100644
--- a/app/api/core/foundation/dependencies.py
+++ b/app/api/core/foundation/dependencies.py
@@ -7,6 +7,18 @@ from sqlalchemy.ext.asyncio import AsyncSession
 
 from core.foundation.database.connection import get_mongo_db, get_postgres_pool
 from core.foundation.database.database import get_db_session
+from core.foundation.security import SecurityService, security_service
+from services.auth_service import AuthService
+from services.email_service import EmailService
+from services.external_client_service import ExternalClient
+from services.floor_canvas_service import FloorCanvasService
+from services.payment_service import P24Service
+from services.tenant_service import TenantService
+from services.user_service import UserService
+
+
+def get_user_service() -> UserService:
+    return UserService(security=security_service)
 
 
 async def get_mongo_database() -> AsyncIOMotorDatabase:
@@ -17,6 +29,45 @@ async def get_postgres_connection_pool() -> Pool:
     return await get_postgres_pool()
 
 
+def get_security_service() -> SecurityService:
+    return security_service
+
+
+def get_auth_service(
+    security: SecurityService = Depends(get_security_service),
+) -> AuthService:
+    return AuthService(security=security)
+
+
+def get_email_service() -> EmailService:
+    return EmailService()
+
+
+def get_tenant_service() -> TenantService:
+    return TenantService()
+
+
+def get_floor_canvas_service() -> FloorCanvasService:
+    return FloorCanvasService()
+
+
+def get_p24_service() -> P24Service:
+    return P24Service()
+
+
+def get_external_client() -> ExternalClient:
+    return ExternalClient()
+
+
+SecurityServiceDep = Annotated[SecurityService, Depends(get_security_service)]
+AuthServiceDep = Annotated[AuthService, Depends(get_auth_service)]
+EmailServiceDep = Annotated[EmailService, Depends(get_email_service)]
+TenantServiceDep = Annotated[TenantService, Depends(get_tenant_service)]
+FloorCanvasServiceDep = Annotated[FloorCanvasService, Depends(get_floor_canvas_service)]
+P24ServiceDep = Annotated[P24Service, Depends(get_p24_service)]
+ExternalClientDep = Annotated[ExternalClient, Depends(get_external_client)]
+UserServiceDep = Annotated[UserService, Depends(get_user_service)]
+
 MongoDB = Annotated[AsyncIOMotorDatabase, Depends(get_mongo_database)]
 PostgresPool = Annotated[Pool, Depends(get_postgres_connection_pool)]
 PostgresSession = Annotated[AsyncSession, Depends(get_db_session)]
diff --git a/app/api/core/foundation/http/__init__.py b/app/api/core/foundation/http/__init__.py
index b0b900a..e69de29 100644
--- a/app/api/core/foundation/http/__init__.py
+++ b/app/api/core/foundation/http/__init__.py
@@ -1,5 +0,0 @@
-from core.foundation.http import responses, router, schemas
-
-__all__ = ["responses", "router", "schemas"]
-
-MSG_NOT_IMPLEMENTED = "Endpoint to be implemented"
diff --git a/app/api/core/foundation/http/consts.py b/app/api/core/foundation/http/consts.py
new file mode 100644
index 0000000..36c561f
--- /dev/null
+++ b/app/api/core/foundation/http/consts.py
@@ -0,0 +1 @@
+MSG_NOT_IMPLEMENTED = "Not implemented"
diff --git a/app/api/core/foundation/http/external_client.py b/app/api/core/foundation/http/external_client.py
deleted file mode 100644
index 778f1b9..0000000
--- a/app/api/core/foundation/http/external_client.py
+++ /dev/null
@@ -1,55 +0,0 @@
-from __future__ import annotations
-
-from typing import Any
-
-import httpx
-
-from core.exceptions import ExternalAPIError, ServiceUnavailableError
-
-
-async def external_post_json(
-    url: str,
-    *,
-    json: dict[str, Any],
-    headers: dict[str, str] | None = None,
-    timeout: float = 30.0,
-    service_name: str = "External API",
-) -> dict[str, Any]:
-    """POST JSON to an external API. Returns parsed JSON on success.
-    Raises ExternalAPIError on 4xx/5xx, ServiceUnavailableError on connection/timeout.
-    """
-    merged_headers = {"Content-Type": "application/json", **(headers or {})}
-    async with httpx.AsyncClient() as client:
-        try:
-            response = await client.post(
-                url,
-                json=json,
-                headers=merged_headers,
-                timeout=timeout,
-            )
-            response.raise_for_status()
-            return response.json()
-        except httpx.HTTPStatusError as e:
-            error_message = _extract_error_message(e)
-            raise ExternalAPIError(
-                status_code=e.response.status_code,
-                message=f"{service_name} error: {error_message}",
-            ) from e
-        except httpx.RequestError as e:
-            raise ServiceUnavailableError(
-                message=f"Failed to connect to {service_name}: {e!s}",
-            ) from e
-
-
-def _extract_error_message(e: httpx.HTTPStatusError) -> str:
-    try:
-        body = e.response.json()
-        if isinstance(body, dict):
-            inner = body.get("error") or body.get("errors") or body
-            if isinstance(inner, dict) and "message" in inner:
-                return str(inner["message"])
-            if isinstance(inner, str):
-                return inner
-        return e.response.text or str(e)
-    except Exception:
-        return e.response.text or str(e)
diff --git a/app/api/core/foundation/http/responses.py b/app/api/core/foundation/http/responses.py
index acb68a2..a31ba1b 100644
--- a/app/api/core/foundation/http/responses.py
+++ b/app/api/core/foundation/http/responses.py
@@ -1,81 +1,61 @@
-from fastapi import status
-from fastapi.responses import JSONResponse
-
-from core.foundation.http.schemas import (
-    CreatedResponse,
-    DeletedResponse,
-    ErrorResponse,
-    PaginatedResponse,
-    SuccessResponse,
-    UpdatedResponse,
-)
-
-
-def success_response[T](
-    data: T,
-    message: str | None = None,
-    status_code: int = status.HTTP_200_OK,
-) -> JSONResponse:
-    response = SuccessResponse[T](message=message, data=data)
-    return JSONResponse(
-        status_code=status_code,
-        content=response.model_dump(exclude_none=True),
-    )
-
-
-def created_response[T](
-    data: T,
-    message: str = "Resource created successfully",
-) -> JSONResponse:
-    response = CreatedResponse[T](message=message, data=data)
-    return JSONResponse(
-        status_code=status.HTTP_201_CREATED,
-        content=response.model_dump(),
-    )
-
-
-def updated_response[T](
-    data: T,
-    message: str = "Resource updated successfully",
-) -> JSONResponse:
-    response = UpdatedResponse[T](message=message, data=data)
-    return JSONResponse(
-        status_code=status.HTTP_200_OK,
-        content=response.model_dump(),
-    )
-
-
-def deleted_response(
-    message: str = "Resource deleted successfully",
-) -> JSONResponse:
-    response = DeletedResponse(message=message)
-    return JSONResponse(
-        status_code=status.HTTP_200_OK,
-        content=response.model_dump(),
-    )
-
-
-def paginated_response[T](
-    paginated_data: PaginatedResponse[T],
-) -> JSONResponse:
-    return JSONResponse(
-        status_code=status.HTTP_200_OK,
-        content=paginated_data.model_dump(),
-    )
-
-
-def error_response(
-    error_code: str,
-    message: str,
-    status_code: int = status.HTTP_400_BAD_REQUEST,
-    details: dict | None = None,
-) -> JSONResponse:
-    response = ErrorResponse(
-        error_code=error_code,
-        message=message,
-        details=details,
-    )
-    return JSONResponse(
-        status_code=status_code,
-        content=response.model_dump(exclude_none=True),
-    )
+from typing import TypeVar
+
+from pydantic import BaseModel
+
+T = TypeVar("T")
+
+
+class SuccessResponse[T](BaseModel):
+    message: str | None = None
+    data: T
+
+
+class CreatedResponse[T](BaseModel):
+    message: str = "Resource created successfully"
+    data: T
+
+
+class UpdatedResponse[T](BaseModel):
+    message: str = "Resource updated successfully"
+    data: T
+
+
+class DeletedResponse(BaseModel):
+    message: str = "Resource deleted successfully"
+
+
+class ErrorResponse(BaseModel):
+    error_code: str
+    message: str
+    details: dict | None = None
+
+
+class ValidationErrorResponse(BaseModel):
+    error_code: str = "VALIDATION_ERROR"
+    message: str = "Validation failed"
+    errors: list[dict[str, str]]
+
+
+class PaginatedResponse[T](BaseModel):
+    items: list[T]
+    total: int
+    page: int
+    page_size: int
+    total_pages: int
+
+    @classmethod
+    def create(
+        cls,
+        items: list[T],
+        total: int,
+        page: int,
+        page_size: int,
+    ) -> "PaginatedResponse[T]":
+        total_pages = (total + page_size - 1) // page_size if page_size > 0 else 0
+        return cls(
+            items=items,
+            total=total,
+            page=page,
+            page_size=page_size,
+            total_pages=total_pages,
+        )
diff --git a/app/api/core/foundation/http/router.py b/app/api/core/foundation/http/router.py
deleted file mode 100644
index 26e5a62..0000000
--- a/app/api/core/foundation/http/router.py
+++ /dev/null
@@ -1,50 +0,0 @@
-from collections.abc import Callable
-import time
-
-from fastapi import APIRouter, Request, Response
-from fastapi.routing import APIRoute
-
-
-class RouterSingleton:
-    _instance: "RouterSingleton | None" = None
-    _router: APIRouter | None = None
-
-    def __new__(cls) -> "RouterSingleton":
-        if cls._instance is None:
-            cls._instance = super().__new__(cls)
-        return cls._instance
-
-    @property
-    def router(self) -> APIRouter:
-        if self._router is None:
-            self._router = APIRouter()
-        return self._router
-
-    def reset(self) -> None:
-        self._router = None
-
-
-def create_router(
-    prefix: str = "",
-    tags: list[str] | None = None,
-    dependencies: list | None = None,
-) -> APIRouter:
-    return APIRouter(
-        prefix=prefix,
-        tags=tags or [],
-        dependencies=dependencies or [],
-    )
-
-
-class TimedRoute(APIRoute):
-    def get_route_handler(self) -> Callable:
-        original_route_handler = super().get_route_handler()
-
-        async def custom_route_handler(request: Request) -> Response:
-            before = time.time()
-            response: Response = await original_route_handler(request)
-            duration = time.time() - before
-            response.headers["X-Process-Time"] = str(duration)
-            return response
-
-        return custom_route_handler
diff --git a/app/api/core/foundation/http/schemas.py b/app/api/core/foundation/http/schemas.py
deleted file mode 100644
index a31ba1b..0000000
--- a/app/api/core/foundation/http/schemas.py
+++ /dev/null
@@ -1,61 +0,0 @@
-from typing import TypeVar
-
-from pydantic import BaseModel
-
-T = TypeVar("T")
-
-
-class SuccessResponse[T](BaseModel):
-    message: str | None = None
-    data: T
-
-
-class CreatedResponse[T](BaseModel):
-    message: str = "Resource created successfully"
-    data: T
-
-
-class UpdatedResponse[T](BaseModel):
-    message: str = "Resource updated successfully"
-    data: T
-
-
-class DeletedResponse(BaseModel):
-    message: str = "Resource deleted successfully"
-
-
-class ErrorResponse(BaseModel):
-    error_code: str
-    message: str
-    details: dict | None = None
-
-
-class ValidationErrorResponse(BaseModel):
-    error_code: str = "VALIDATION_ERROR"
-    message: str = "Validation failed"
-    errors: list[dict[str, str]]
-
-
-class PaginatedResponse[T](BaseModel):
-    items: list[T]
-    total: int
-    page: int
-    page_size: int
-    total_pages: int
-
-    @classmethod
-    def create(
-        cls,
-        items: list[T],
-        total: int,
-        page: int,
-        page_size: int,
-    ) -> "PaginatedResponse[T]":
-        total_pages = (total + page_size - 1) // page_size if page_size > 0 else 0
-        return cls(
-            items=items,
-            total=total,
-            page=page,
-            page_size=page_size,
-            total_pages=total_pages,
-        )
diff --git a/app/api/core/foundation/infra/config.py b/app/api/core/foundation/infra/config.py
index 0d54aca..aa682f8 100644
--- a/app/api/core/foundation/infra/config.py
+++ b/app/api/core/foundation/infra/config.py
@@ -12,7 +12,13 @@ class Settings(BaseSettings):
 
     API_V1_PREFIX: str = "/api/v1"
 
-    CORS_ORIGINS: list[str] = ["*"]
+    CORS_ORIGINS: list[str] = [
+        "localhost:3000",
+        "localhost:3001",
+        "localhost:3002",
+        "localhost:3003",
+        "localhost:3004",
+    ]
 
     @field_validator("CORS_ORIGINS", mode="before")
     @classmethod
diff --git a/app/api/core/foundation/security.py b/app/api/core/foundation/security.py
index c8ba4a1..c4fef4e 100644
--- a/app/api/core/foundation/security.py
+++ b/app/api/core/foundation/security.py
@@ -1,33 +1,59 @@
 from datetime import UTC, datetime, timedelta
 
-import bcrypt
+from bcrypt import checkpw, gensalt, hashpw
+from fastapi import Request
 from jose import JWTError, jwt
 
+from core.exceptions.http import UnauthorizedError
 from core.foundation.infra.config import settings
+from core.foundation.logging.logger import logger
 
 
-def hash_password(password: str) -> str:
-    password_bytes = password.encode("utf-8")
-    salt = bcrypt.gensalt()
-    return bcrypt.hashpw(password_bytes, salt).decode("utf-8")
+async def get_current_user(self, request: Request) -> dict | None:
+    auth_header = request.headers.get("Authorization")
+    if not auth_header or not auth_header.startswith("Bearer "):
+        raise UnauthorizedError(message="Unauthorized")
 
+    token = auth_header.split(" ")[1]
+    return self.decode_access_token(token=token)
 
-def verify_password(password: str, hashed_password: str) -> bool:
-    return bcrypt.checkpw(password.encode("utf-8"), hashed_password.encode("utf-8"))
 
+class SecurityService:
+    def __init__(self) -> None:
+        self._algorithm = settings.ALGORITHM
+        self._secret_key = settings.SECRET_KEY
+        self._access_token_expire_minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES
 
-def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
-    to_encode = data.copy()
-    if expires_delta:
-        expire = datetime.now(UTC) + expires_delta
-    else:
-        expire = datetime.now(UTC) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
-    to_encode.update({"exp": expire})
-    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
+    @staticmethod
+    def hash_password(password: str) -> str:
+        password_bytes = password.encode("utf-8")
+        salt = gensalt()
+        return hashpw(password_bytes, salt).decode("utf-8")
 
+    @staticmethod
+    def verify_password(password: str, hashed_password: str) -> bool:
+        return checkpw(password.encode("utf-8"), hashed_password.encode("utf-8"))
 
-def decode_access_token(token: str) -> dict | None:
-    try:
-        return jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
-    except JWTError:
-        return None
+    def create_access_token(self, data: dict, expires_delta: timedelta | None = None) -> str:
+        to_encode = data.copy()
+        if expires_delta:
+            expire = datetime.now(UTC) + expires_delta
+        else:
+            expire = datetime.now(UTC) + timedelta(minutes=self._access_token_expire_minutes)
+        to_encode.update({"exp": expire})
+        return jwt.encode(to_encode, self._secret_key, algorithm=self._algorithm)
+
+    def decode_access_token(self, token: str) -> dict:
+        try:
+            return jwt.decode(token, self._secret_key, algorithms=[self._algorithm])
+        except JWTError as err:
+            logger.error(f"Invalid token: {err!s}", exc_info=True)
+
+            raise UnauthorizedError(message="Unauthorized") from None
+        except Exception as err:
+            logger.error(f"Invalid token: {err!s}", exc_info=True)
+
+            raise UnauthorizedError(message="Unauthorized") from None
+
+
+security_service = SecurityService()
diff --git a/app/api/core/middleware/unauthorized.py b/app/api/core/middleware/unauthorized.py
index f602bfe..0d35aec 100644
--- a/app/api/core/middleware/unauthorized.py
+++ b/app/api/core/middleware/unauthorized.py
@@ -1,18 +1,49 @@
-from fastapi import Request
+from collections.abc import Awaitable, Callable
+
+from fastapi import Request, Response
 from fastapi.responses import JSONResponse
+from starlette import status
 from starlette.middleware.base import BaseHTTPMiddleware
+from starlette.types import ASGIApp
 
-from core.consts.status_codes import NOT_FOUND_STATUS_CODE, UNAUTHORIZED_STATUS_CODE
+from core.foundation.security import security_service
 
 
 class UnauthorizedMiddleware(BaseHTTPMiddleware):
-    async def dispatch(self, request: Request, call_next):
-        response = await call_next(request)
+    def __init__(self, app: ASGIApp) -> None:
+        self._security = security_service
+        super().__init__(app)
+
+    async def dispatch(
+        self, request: Request, call_next: Callable[[Request], Awaitable[Response]]
+    ) -> Response:
+        # Allow public routes
+        if (
+            request.url.path.startswith("/docs")
+            or request.url.path.startswith("/openapi")
+            or request.url.path.startswith("/health")
+        ):
+            return await call_next(request)
+
+        auth_header = request.headers.get("Authorization")
 
-        if response.status_code == NOT_FOUND_STATUS_CODE:
+        if not auth_header or not auth_header.startswith("Bearer "):
             return JSONResponse(
-                status_code=UNAUTHORIZED_STATUS_CODE,
+                status_code=status.HTTP_401_UNAUTHORIZED,
                 content={"message": "Unauthorized"},
             )
 
-        return response
+        token = auth_header.split(" ", 1)[1]
+
+        try:
+            user = self._security.decode_access_token(token)  # should raise if invalid
+        except Exception:
+            return JSONResponse(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                content={"message": "Unauthorized"},
+            )
+
+        # Attach user to request context
+        request.state.user = user
+
+        return await call_next(request)
diff --git a/app/api/core/models/__init__.py b/app/api/core/models/__init__.py
index 5197f8a..8ba479c 100644
--- a/app/api/core/models/__init__.py
+++ b/app/api/core/models/__init__.py
@@ -16,7 +16,6 @@ from core.models.tenant import Tenant
 from core.models.tenant_role import TenantRole
 from core.models.user import User
 from core.models.user_tenant import UserTenant
-from core.models.venue import Venue
 
 __all__ = [
     "ActivationLink",
@@ -36,5 +35,4 @@ __all__ = [
     "TenantStatus",
     "User",
     "UserTenant",
-    "Venue",
 ]
diff --git a/app/api/core/models/floor_canvas.py b/app/api/core/models/floor_canvas.py
index 6d839ba..1fa15b0 100644
--- a/app/api/core/models/floor_canvas.py
+++ b/app/api/core/models/floor_canvas.py
@@ -12,16 +12,16 @@ from sqlalchemy.orm import Mapped, mapped_column, relationship
 from core.foundation.database.database import Base
 
 if TYPE_CHECKING:
-    from core.models.venue import Venue
+    from core.models.tenant import Tenant
 
 
 class FloorCanvas(Base):
     __tablename__ = "floor_canvases"
 
     id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True, default=uuid4)
-    venue_id: Mapped[UUID] = mapped_column(
+    tenant_id: Mapped[UUID] = mapped_column(
         PGUUID(as_uuid=True),
-        ForeignKey("venues.id", ondelete="CASCADE"),
+        ForeignKey("tenants.id", ondelete="CASCADE"),
         nullable=False,
     )
     name: Mapped[str] = mapped_column(String(255), nullable=False)
@@ -36,8 +36,8 @@ class FloorCanvas(Base):
         DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now()
     )
 
-    venue: Mapped[Venue] = relationship(
-        "Venue", back_populates="floor_canvases", foreign_keys=[venue_id]
+    tenant: Mapped[Tenant] = relationship(
+        "Tenant", back_populates="floor_canvases", foreign_keys=[tenant_id]
     )
 
-    __table_args__ = (Index("idx_floor_canvases_venue_id", "venue_id"),)
+    __table_args__ = (Index("idx_floor_canvases_tenant_id", "tenant_id"),)
diff --git a/app/api/core/models/tenant.py b/app/api/core/models/tenant.py
index cbb9034..77c24c8 100644
--- a/app/api/core/models/tenant.py
+++ b/app/api/core/models/tenant.py
@@ -13,11 +13,11 @@ from core.models.enums import TenantStatus
 
 if TYPE_CHECKING:
     from core.models.audit_log import AuditLog
+    from core.models.floor_canvas import FloorCanvas
     from core.models.order import Order
     from core.models.restaurant_table import RestaurantTable
     from core.models.tenant_role import TenantRole
     from core.models.user_tenant import UserTenant
-    from core.models.venue import Venue
 
 
 class Tenant(Base):
@@ -36,6 +36,11 @@ class Tenant(Base):
         nullable=False,
         default=TenantStatus.ACTIVE,
     )
+    active_layout_version_id: Mapped[UUID | None] = mapped_column(
+        PGUUID(as_uuid=True),
+        ForeignKey("floor_canvases.id", ondelete="SET NULL", use_alter=True),
+        nullable=True,
+    )
     created_at: Mapped[datetime] = mapped_column(
         DateTime(timezone=True), nullable=False, server_default=func.now()
     )
@@ -58,6 +63,9 @@ class Tenant(Base):
     audit_logs: Mapped[list[AuditLog]] = relationship(
         "AuditLog", back_populates="tenant", cascade="all, delete-orphan"
     )
-    venues: Mapped[list[Venue]] = relationship(
-        "Venue", back_populates="tenant", cascade="all, delete-orphan"
+    floor_canvases: Mapped[list[FloorCanvas]] = relationship(
+        "FloorCanvas",
+        back_populates="tenant",
+        cascade="all, delete-orphan",
+        foreign_keys="FloorCanvas.tenant_id",
     )
diff --git a/app/api/core/models/venue.py b/app/api/core/models/venue.py
deleted file mode 100644
index a767c8e..0000000
--- a/app/api/core/models/venue.py
+++ /dev/null
@@ -1,48 +0,0 @@
-from __future__ import annotations
-
-from datetime import datetime
-from typing import TYPE_CHECKING
-from uuid import UUID, uuid4
-
-from sqlalchemy import DateTime, ForeignKey, Index, String, func
-from sqlalchemy.dialects.postgresql import UUID as PGUUID
-from sqlalchemy.orm import Mapped, mapped_column, relationship
-
-from core.foundation.database.database import Base
-
-if TYPE_CHECKING:
-    from core.models.floor_canvas import FloorCanvas
-    from core.models.tenant import Tenant
-
-
-class Venue(Base):
-    __tablename__ = "venues"
-
-    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True, default=uuid4)
-    tenant_id: Mapped[UUID] = mapped_column(
-        PGUUID(as_uuid=True),
-        ForeignKey("tenants.id", ondelete="CASCADE"),
-        nullable=False,
-    )
-    name: Mapped[str] = mapped_column(String(255), nullable=False)
-    active_layout_version_id: Mapped[UUID | None] = mapped_column(
-        PGUUID(as_uuid=True),
-        ForeignKey("floor_canvases.id", ondelete="SET NULL", use_alter=True),
-        nullable=True,
-    )
-    created_at: Mapped[datetime] = mapped_column(
-        DateTime(timezone=True), nullable=False, server_default=func.now()
-    )
-    updated_at: Mapped[datetime] = mapped_column(
-        DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now()
-    )
-
-    tenant: Mapped[Tenant] = relationship("Tenant", back_populates="venues")
-    floor_canvases: Mapped[list[FloorCanvas]] = relationship(
-        "FloorCanvas",
-        back_populates="venue",
-        cascade="all, delete-orphan",
-        foreign_keys="FloorCanvas.venue_id",
-    )
-
-    __table_args__ = (Index("idx_venues_tenant_id", "tenant_id"),)
diff --git a/app/api/core/repositories/tenant_repository.py b/app/api/core/repositories/tenant_repository.py
new file mode 100644
index 0000000..4df220f
--- /dev/null
+++ b/app/api/core/repositories/tenant_repository.py
@@ -0,0 +1,31 @@
+from uuid import UUID
+
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from core.models import Tenant
+
+
+class TenantRepository:
+    async def find_by_id(self, session: AsyncSession, id: UUID) -> Tenant | None:
+        pass
+
+    async def find_by_id_with_canvases(self, session: AsyncSession, id: UUID) -> Tenant | None:
+        pass
+
+    async def find_all(self, session: AsyncSession) -> list[Tenant]:
+        pass
+
+    async def save(self, session: AsyncSession, tenant: Tenant) -> Tenant:
+        pass
+
+    async def delete(self, session: AsyncSession, tenant: Tenant) -> None:
+        pass
+
+    async def create(self, session: AsyncSession, tenant: Tenant) -> Tenant:
+        pass
+
+    async def update(self, session: AsyncSession, tenant: Tenant) -> Tenant:
+        pass
+
+    async def delete(self, session: AsyncSession, tenant: Tenant) -> None:
+        pass
diff --git a/app/api/docs/dto_layer_guide.md b/app/api/docs/dto_layer_guide.md
index fd4314e..2753e06 100644
--- a/app/api/docs/dto_layer_guide.md
+++ b/app/api/docs/dto_layer_guide.md
@@ -63,7 +63,7 @@ api/v1/dto/
 All DTOs inherit from `BaseDTO`:
 
 ```python
-from api.v1.dto.common import BaseDTO
+from core.dto.v1.common import BaseDTO
 
 class MyDTO(BaseDTO):
     field: str
@@ -130,7 +130,7 @@ class TenantResponseDTO(BaseDTO):
 ### In Route Handlers
 
 ```python
-from api.v1.dto.tenants import CreateTenantDTO, TenantResponseDTO
+from core.dto.v1.tenants import CreateTenantDTO, TenantResponseDTO
 
 @router.post("")
 async def create_tenant(
@@ -266,7 +266,7 @@ Path-based versioning:
 The legacy `postgres_models.py` file has been deprecated. Use:
 
 - **For ORM operations**: `core.models.*`
-- **For API endpoints**: `api.v1.dto.*`
+- **For API endpoints**: `core.dto.v1.*`
 
 See deprecation notice in `core/foundation/database/postgres_models.py`.
 
diff --git a/app/api/modules/__init__.py b/app/api/modules/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/app/api/modules/auth/__init__.py b/app/api/modules/auth/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/app/api/modules/auth/service.py b/app/api/modules/auth/service.py
deleted file mode 100644
index a810302..0000000
--- a/app/api/modules/auth/service.py
+++ /dev/null
@@ -1,173 +0,0 @@
-from datetime import UTC, datetime, timedelta
-from uuid import UUID
-
-from sqlalchemy import select
-from sqlalchemy.ext.asyncio import AsyncSession
-
-from core.exceptions import (
-    BadRequestError,
-    ConflictError,
-    GoneError,
-    NotFoundError,
-    TooManyRequestsError,
-)
-from core.foundation.security import hash_password
-from core.models.activation_link import ActivationLink
-from core.models.enums import AccountType, TenantStatus
-from core.models.tenant import Tenant
-from core.models.tenant_role import TenantRole
-from core.models.user import User
-from core.models.user_tenant import UserTenant
-
-
-async def create_user_with_tenant(
-    *,
-    session: AsyncSession,
-    email: str,
-    password: str,
-    restaurant_name: str,
-) -> tuple[User, Tenant, TenantRole]:
-    slug = "".join(restaurant_name.split()).lower()
-
-    existing_user = await session.scalar(select(User).where(User.email == email))
-    if existing_user:
-        msg = "Email already registered"
-        raise ConflictError(msg)
-
-    existing_tenant = await session.scalar(select(Tenant).where(Tenant.slug == slug))
-    if existing_tenant:
-        msg = "Restaurant slug already exists"
-        raise ConflictError(msg)
-
-    user = User(
-        email=email,
-        password_hash=hash_password(password),
-        is_active=False,
-    )
-    tenant = Tenant(
-        name=restaurant_name,
-        slug=slug,
-        status=TenantStatus.INACTIVE,
-    )
-
-    session.add_all([user, tenant])
-    await session.flush()
-    user.tenant_id = tenant.id
-    tenant.owner_id = user.id
-    await session.flush()
-    await session.refresh(user)
-    await session.refresh(tenant)
-
-    user_tenant = UserTenant(
-        user_id=user.id,
-        tenant_id=tenant.id,
-        role=AccountType.OWNER,
-    )
-    tenant_role = TenantRole(
-        account_id=user.id,
-        tenant_id=tenant.id,
-        account_type=AccountType.OWNER,
-    )
-    session.add_all([user_tenant, tenant_role])
-    await session.flush()
-
-    return user, tenant, tenant_role
-
-
-async def create_activation_link(
-    *,
-    session: AsyncSession,
-    email: str,
-    user_id: UUID,
-    tenant_id: UUID,
-) -> ActivationLink:
-    activation_link = ActivationLink(
-        email=email,
-        user_id=user_id,
-        tenant_id=tenant_id,
-        expires_at=datetime.now(tz=UTC) + timedelta(hours=24),
-    )
-    session.add(activation_link)
-    await session.flush()
-    await session.refresh(activation_link)
-    return activation_link
-
-
-async def activate_account(
-    *,
-    session: AsyncSession,
-    activation_id: UUID,
-) -> tuple[Tenant, bool]:
-    """Returns (tenant, already_activated)."""
-    activation_link = await session.get(ActivationLink, activation_id)
-    if activation_link is None:
-        msg = "Activation link not found"
-        raise NotFoundError(msg, str(activation_id))
-
-    now = datetime.now(tz=UTC)
-    if activation_link.expires_at < now:
-        msg = "Activation link has expired"
-        raise GoneError(msg)
-
-    tenant = await session.get(Tenant, activation_link.tenant_id)
-    if tenant is None:
-        msg = "Account"
-        raise NotFoundError(msg, "activation link")
-
-    if activation_link.used_at is not None:
-        return tenant, True
-
-    user = await session.get(User, activation_link.user_id)
-    if user is None:
-        msg = "Account"
-        raise NotFoundError(msg, "activation link")
-    user.is_active = True
-    tenant.status = TenantStatus.ACTIVE
-    activation_link.used_at = now
-    return tenant, False
-
-
-RESEND_COOLDOWN_SECONDS = 300
-
-
-async def resend_activation_link(
-    *,
-    session: AsyncSession,
-    activation_id: UUID,
-) -> tuple[ActivationLink, Tenant]:
-    """Resend only when link is expired. Cooldown is per activation link (last_resend_at)."""
-    activation_link = await session.get(ActivationLink, activation_id)
-    if activation_link is None:
-        msg = "Activation link"
-        raise NotFoundError(msg, str(activation_id))
-
-    now = datetime.now(tz=UTC)
-    if activation_link.used_at is not None:
-        msg = "Account already activated"
-        raise BadRequestError(msg)
-    if activation_link.expires_at >= now:
-        msg = "Activation link has not expired yet"
-        raise BadRequestError(msg)
-
-    if activation_link.last_resend_at is not None:
-        elapsed = (now - activation_link.last_resend_at).total_seconds()
-        if elapsed < RESEND_COOLDOWN_SECONDS:
-            msg = "Please wait before requesting another activation email."
-            raise TooManyRequestsError(msg)
-
-    activation_link.last_resend_at = now
-    tenant = await session.get(Tenant, activation_link.tenant_id)
-    if tenant is None:
-        msg = "Account"
-        raise NotFoundError(msg, "activation link")
-
-    new_link = ActivationLink(
-        email=activation_link.email,
-        user_id=activation_link.user_id,
-        tenant_id=activation_link.tenant_id,
-        expires_at=now + timedelta(hours=24),
-    )
-    session.add(new_link)
-    await session.flush()
-    await session.refresh(new_link)
-    return new_link, tenant
diff --git a/app/api/modules/email/service.py b/app/api/modules/email/service.py
deleted file mode 100644
index e08c715..0000000
--- a/app/api/modules/email/service.py
+++ /dev/null
@@ -1,46 +0,0 @@
-from __future__ import annotations
-
-import asyncio
-
-import resend
-
-from core.foundation.infra.config import settings
-
-
-def _get_resend_settings() -> tuple[str, str]:
-    resend_api_key = settings.RESEND_API_KEY.strip()
-    resend_from_email = settings.RESEND_FROM_EMAIL.strip()
-    if not resend_api_key:
-        msg = "RESEND_API_KEY is required to send emails."
-        raise RuntimeError(msg)
-    if not resend_from_email:
-        msg = "RESEND_FROM_EMAIL is required to send emails."
-        raise RuntimeError(msg)
-    return resend_api_key, resend_from_email
-
-
-async def send_activation_email(
-    *,
-    to_email: str,
-    restaurant_name: str,
-    activation_link: str,
-) -> None:
-    resend_api_key, resend_from_email = _get_resend_settings()
-    resend.api_key = resend_api_key
-
-    subject = f"Activate your {restaurant_name} account"
-    html = f"""
-    <p>Welcome to Restorio, {restaurant_name}!</p>
-    <p>Please activate your account:</p>
-    <p><a href="{activation_link}">Activate my account</a></p>
-    """
-
-    await asyncio.to_thread(
-        resend.Emails.send,
-        {
-            "from": resend_from_email,
-            "to": [to_email],
-            "subject": subject,
-            "html": html,
-        },
-    )
diff --git a/app/api/modules/orders/__init__.py b/app/api/modules/orders/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/app/api/modules/restaurants/__init__.py b/app/api/modules/restaurants/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/app/api/modules/tenants/__init__.py b/app/api/modules/tenants/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/app/api/routes/__init__.py b/app/api/routes/__init__.py
index 5aae5ba..54f1fe9 100644
--- a/app/api/routes/__init__.py
+++ b/app/api/routes/__init__.py
@@ -1,13 +1,12 @@
 from fastapi import APIRouter
 
-from routes.v1 import auth, health, orders, payments, restaurants, tenants, venues
+from routes.v1 import auth, health, orders, payments, restaurants, tenants
 
 api_router = APIRouter()
 
 api_router.include_router(health.router, prefix="/health", tags=["health"])
 api_router.include_router(auth.router, prefix="/auth", tags=["authentication"])
 api_router.include_router(tenants.router, prefix="/tenants", tags=["tenants"])
-api_router.include_router(restaurants.router, prefix="/restaurants", tags=["restaurants"])
 api_router.include_router(orders.router, prefix="/orders", tags=["orders"])
 api_router.include_router(payments.router, prefix="/payments", tags=["payments"])
-api_router.include_router(venues.router, prefix="/venues", tags=["venues"])
+api_router.include_router(restaurants.router, prefix="/restaurants", tags=["restaurants"])
diff --git a/app/api/routes/v1/__init__.py b/app/api/routes/v1/__init__.py
index e69de29..13c124c 100644
--- a/app/api/routes/v1/__init__.py
+++ b/app/api/routes/v1/__init__.py
@@ -0,0 +1,15 @@
+# from routes.v1.menus import router as menus_router  # noqa: ERA001
+from routes.v1.orders import router as orders_router
+from routes.v1.payments import router as payments_router
+from routes.v1.restaurants import router as restaurants_router
+from routes.v1.tenants import router as tenants_router
+
+# from routes.v1.users import router as users_router  # noqa: ERA001
+
+__all__ = [
+    "orders_router",
+    "payments_router",
+    "restaurants_router",
+    "tenants_router",
+    # "users_router",
+]
diff --git a/app/api/routes/v1/__template__.py b/app/api/routes/v1/__template__.py
index 9277091..85fbc2a 100644
--- a/app/api/routes/v1/__template__.py
+++ b/app/api/routes/v1/__template__.py
@@ -13,7 +13,7 @@ Best Practices:
 from fastapi import APIRouter, status
 
 from core.foundation.dependencies import MongoDB, PostgresPool
-from core.foundation.http.schemas import (
+from core.foundation.http.responses import (
     CreatedResponse,
     DeletedResponse,
     PaginatedResponse,
diff --git a/app/api/routes/v1/auth.py b/app/api/routes/v1/auth.py
index d594b97..2d59181 100644
--- a/app/api/routes/v1/auth.py
+++ b/app/api/routes/v1/auth.py
@@ -1,20 +1,16 @@
 from uuid import UUID
 
 from fastapi import APIRouter, status
-from fastapi.responses import JSONResponse
 
-from api.v1.dto.auth import RegisterCreatedData, RegisterDTO, TenantSlugData
-from api.v1.dto.users import UserLoginDTO
-from core.foundation.dependencies import PostgresSession
-from core.foundation.http.responses import created_response, success_response
-from core.foundation.infra.config import settings
-from modules.auth.service import (
-    activate_account,
-    create_activation_link,
-    create_user_with_tenant,
-    resend_activation_link,
+from core.dto.v1.auth import RegisterCreatedData, RegisterDTO, TenantSlugData
+from core.dto.v1.users import UserLoginDTO
+from core.foundation.dependencies import (
+    EmailServiceDep,
+    PostgresSession,
+    UserServiceDep,
 )
-from modules.email.service import send_activation_email
+from core.foundation.http.responses import CreatedResponse, SuccessResponse
+from core.foundation.infra.config import settings
 
 router = APIRouter()
 
@@ -24,31 +20,43 @@ async def login(credentials: UserLoginDTO) -> dict[str, str]:  # noqa: ARG001
     return {"message": "Login endpoint - to be implemented"}
 
 
-@router.post("/register", status_code=status.HTTP_201_CREATED)
-async def register(data: RegisterDTO, session: PostgresSession) -> JSONResponse:
-    user, tenant, tenant_role = await create_user_with_tenant(
+@router.post(
+    "/register",
+    response_description="User and tenant created successfully",
+    status_code=status.HTTP_201_CREATED,
+    response_model=CreatedResponse[RegisterCreatedData],
+    summary="Register a new user and tenant",
+    description="Register a new user and tenant",
+)
+async def register(
+    data: RegisterDTO,
+    session: PostgresSession,
+    user_service: UserServiceDep,
+    email_service: EmailServiceDep,
+) -> CreatedResponse[RegisterCreatedData]:
+    user, tenant, _ = await user_service.create_user_with_tenant(
         session=session,
         email=data.email,
         password=data.password,
         restaurant_name=data.restaurant_name,
     )
-    activation = await create_activation_link(
+    activation = await email_service.create_activation_link(
         session=session,
         email=user.email,
         user_id=user.id,
         tenant_id=tenant.id,
     )
     activation_link = f"{settings.FRONTEND_URL}/activate?activation_id={activation.id}"
-    await send_activation_email(
+    await email_service.send_activation_email(
         to_email=user.email,
         restaurant_name=tenant.name,
         activation_link=activation_link,
     )
-    return created_response(
+
+    return CreatedResponse(
         data=RegisterCreatedData(
             user_id=str(user.id),
             email=user.email,
-            account_type=tenant_role.account_type.value,
             tenant_id=str(tenant.id),
             tenant_name=tenant.name,
             tenant_slug=tenant.slug,
@@ -57,27 +65,51 @@ async def register(data: RegisterDTO, session: PostgresSession) -> JSONResponse:
     )
 
 
-@router.post("/activate", status_code=status.HTTP_200_OK)
-async def activate(activation_id: UUID, session: PostgresSession) -> JSONResponse:
-    tenant, already_activated = await activate_account(session=session, activation_id=activation_id)
-    return success_response(
+@router.post(
+    "/activate",
+    status_code=status.HTTP_200_OK,
+    response_model=SuccessResponse[TenantSlugData],
+    summary="Activate a tenant account",
+    description="Activate a tenant account",
+    response_description="Tenant activated successfully",
+)
+async def activate(
+    activation_id: UUID, session: PostgresSession, email_service: EmailServiceDep
+) -> SuccessResponse[TenantSlugData]:
+    tenant, already_activated = await email_service.activate_account(
+        session=session, activation_id=activation_id
+    )
+    return SuccessResponse(
         data=TenantSlugData(tenant_slug=tenant.slug),
-        message=(
-            "Account already activated" if already_activated else "Account activated successfully"
-        ),
+        message="Account already activated"
+        if already_activated
+        else "Account activated successfully",
     )
 
 
-@router.post("/resend-activation", status_code=status.HTTP_200_OK)
-async def resend_activation(activation_id: UUID, session: PostgresSession) -> JSONResponse:
-    new_link, tenant = await resend_activation_link(session=session, activation_id=activation_id)
+@router.post(
+    "/resend-activation",
+    status_code=status.HTTP_200_OK,
+    response_model=SuccessResponse[TenantSlugData],
+    summary="Resend activation link",
+    description="Resend activation link",
+    response_description="Activation email sent",
+)
+async def resend_activation(
+    activation_id: UUID,
+    session: PostgresSession,
+    email_service: EmailServiceDep,
+) -> SuccessResponse[TenantSlugData]:
+    new_link, tenant = await email_service.resend_activation_link(
+        session=session, activation_id=activation_id
+    )
     activation_url = f"{settings.FRONTEND_URL}/activate?activation_id={new_link.id}"
-    await send_activation_email(
+    await email_service.send_activation_email(
         to_email=new_link.email,
         restaurant_name=tenant.name,
         activation_link=activation_url,
     )
-    return success_response(
+    return SuccessResponse(
         data=TenantSlugData(tenant_slug=tenant.slug),
         message="Activation email sent",
     )
diff --git a/app/api/routes/v1/dto/floor_canvases/requests.py b/app/api/routes/v1/dto/floor_canvases/requests.py
new file mode 100644
index 0000000..c848ee5
--- /dev/null
+++ b/app/api/routes/v1/dto/floor_canvases/requests.py
@@ -0,0 +1,75 @@
+from typing import Literal
+
+from pydantic import Field
+
+from core.dto.v1.common import BaseDTO
+
+
+class FloorElementBaseDTO(BaseDTO):
+    id: str = Field(..., description="Element identifier")
+    x: float = Field(..., description="X coordinate")
+    y: float = Field(..., description="Y coordinate")
+    w: float = Field(..., description="Width")
+    h: float = Field(..., description="Height")
+    rotation: float | None = Field(None, description="Rotation in degrees")
+    zone_id: str | None = Field(None, alias="zoneId", description="Associated zone id")
+
+
+class FloorTableElementDTO(FloorElementBaseDTO):
+    type: Literal["table"] = "table"
+    table_number: str = Field(..., alias="tableNumber", description="Table display number")
+    seats: int = Field(..., gt=0, description="Number of seats")
+    table_id: str | None = Field(None, alias="tableId", description="Reference to RestaurantTable")
+
+
+class FloorTableGroupElementDTO(FloorElementBaseDTO):
+    type: Literal["tableGroup"] = "tableGroup"
+    table_numbers: list[str] = Field(..., alias="tableNumbers", description="Table display numbers")
+    seats: int = Field(..., gt=0, description="Total seats")
+    table_ids: list[str] | None = Field(
+        None, alias="tableIds", description="References to RestaurantTables"
+    )
+
+
+class FloorBarElementDTO(FloorElementBaseDTO):
+    type: Literal["bar"] = "bar"
+    label: str | None = Field(None, description="Bar label")
+
+
+class FloorZoneElementDTO(FloorElementBaseDTO):
+    type: Literal["zone"] = "zone"
+    name: str = Field(..., description="Zone name")
+    color: str | None = Field(None, description="Zone color (hex)")
+
+
+class FloorWallElementDTO(FloorElementBaseDTO):
+    type: Literal["wall"] = "wall"
+
+
+class FloorEntranceElementDTO(FloorElementBaseDTO):
+    type: Literal["entrance"] = "entrance"
+    label: str | None = Field(None, description="Entrance label")
+
+
+FloorElementDTO = (
+    FloorTableElementDTO
+    | FloorTableGroupElementDTO
+    | FloorBarElementDTO
+    | FloorZoneElementDTO
+    | FloorWallElementDTO
+    | FloorEntranceElementDTO
+)
+
+
+class CreateFloorCanvasDTO(BaseDTO):
+    name: str = Field(..., min_length=1, max_length=255, description="Canvas name")
+    width: int = Field(800, gt=0, description="Canvas width in pixels")
+    height: int = Field(600, gt=0, description="Canvas height in pixels")
+    elements: list[FloorElementDTO] = Field(default_factory=list, description="Floor elements")
+
+
+class UpdateFloorCanvasDTO(BaseDTO):
+    name: str | None = Field(None, min_length=1, max_length=255, description="Canvas name")
+    width: int | None = Field(None, gt=0, description="Canvas width in pixels")
+    height: int | None = Field(None, gt=0, description="Canvas height in pixels")
+    elements: list[FloorElementDTO] | None = Field(None, description="Floor elements")
diff --git a/app/api/routes/v1/dto/floor_canvases/responses.py b/app/api/routes/v1/dto/floor_canvases/responses.py
new file mode 100644
index 0000000..1dd605d
--- /dev/null
+++ b/app/api/routes/v1/dto/floor_canvases/responses.py
@@ -0,0 +1,80 @@
+from datetime import datetime
+from typing import Literal
+
+from pydantic import ConfigDict, Field
+
+from core.dto.v1.common import BaseDTO, EntityId
+
+
+class FloorElementBaseResponseDTO(BaseDTO):
+    id: str = Field(..., description="Element identifier")
+    x: float = Field(..., description="X coordinate")
+    y: float = Field(..., description="Y coordinate")
+    w: float = Field(..., description="Width")
+    h: float = Field(..., description="Height")
+    rotation: float | None = Field(None, description="Rotation in degrees")
+    zone_id: str | None = Field(
+        None, alias="zoneId", serialization_alias="zoneId", description="Associated zone id"
+    )
+
+    model_config = ConfigDict(populate_by_name=True)
+
+
+class FloorTableElementResponseDTO(FloorElementBaseResponseDTO):
+    type: Literal["table"] = "table"
+    table_number: str = Field(..., alias="tableNumber", serialization_alias="tableNumber")
+    seats: int = Field(...)
+    table_id: str | None = Field(None, alias="tableId", serialization_alias="tableId")
+
+
+class FloorTableGroupElementResponseDTO(FloorElementBaseResponseDTO):
+    type: Literal["tableGroup"] = "tableGroup"
+    table_numbers: list[str] = Field(..., alias="tableNumbers", serialization_alias="tableNumbers")
+    seats: int = Field(...)
+    table_ids: list[str] | None = Field(None, alias="tableIds", serialization_alias="tableIds")
+
+
+class FloorBarElementResponseDTO(FloorElementBaseResponseDTO):
+    type: Literal["bar"] = "bar"
+    label: str | None = Field(None)
+
+
+class FloorZoneElementResponseDTO(FloorElementBaseResponseDTO):
+    type: Literal["zone"] = "zone"
+    name: str = Field(...)
+    color: str | None = Field(None)
+
+
+class FloorWallElementResponseDTO(FloorElementBaseResponseDTO):
+    type: Literal["wall"] = "wall"
+
+
+class FloorEntranceElementResponseDTO(FloorElementBaseResponseDTO):
+    type: Literal["entrance"] = "entrance"
+    label: str | None = Field(None)
+
+
+FloorElementResponseDTO = (
+    FloorTableElementResponseDTO
+    | FloorTableGroupElementResponseDTO
+    | FloorBarElementResponseDTO
+    | FloorZoneElementResponseDTO
+    | FloorWallElementResponseDTO
+    | FloorEntranceElementResponseDTO
+)
+
+
+class FloorCanvasResponseDTO(BaseDTO):
+    id: EntityId = Field(..., description="Canvas identifier")
+    tenant_id: EntityId = Field(
+        ..., alias="tenantId", serialization_alias="tenantId", description="Tenant identifier"
+    )
+    name: str = Field(..., description="Canvas name")
+    width: int = Field(..., description="Canvas width in pixels")
+    height: int = Field(..., description="Canvas height in pixels")
+    elements: list[FloorElementResponseDTO] = Field(..., description="Floor elements")
+    version: int = Field(..., description="Canvas version")
+    created_at: datetime = Field(..., alias="createdAt", serialization_alias="createdAt")
+    updated_at: datetime = Field(..., alias="updatedAt", serialization_alias="updatedAt")
+
+    model_config = ConfigDict(populate_by_name=True)
diff --git a/app/api/routes/v1/dto/tenants/responses.py b/app/api/routes/v1/dto/tenants/responses.py
new file mode 100644
index 0000000..66fe721
--- /dev/null
+++ b/app/api/routes/v1/dto/tenants/responses.py
@@ -0,0 +1,36 @@
+from datetime import datetime
+
+from pydantic import Field
+
+from core.dto.v1.common import BaseDTO, EntityId, TenantStatus
+from core.dto.v1.floor_canvases import FloorCanvasResponseDTO
+
+
+class TenantResponseDTO(BaseDTO):
+    id: EntityId = Field(..., description="Unique tenant identifier")
+    name: str = Field(..., description="Tenant name")
+    slug: str = Field(..., description="URL-friendly tenant identifier")
+    status: TenantStatus = Field(..., description="Tenant status")
+    active_layout_version_id: EntityId | None = Field(
+        None, alias="activeLayoutVersionId", serialization_alias="activeLayoutVersionId"
+    )
+    floor_canvases: list[FloorCanvasResponseDTO] = Field(
+        default_factory=list,
+        alias="floorCanvases",
+        serialization_alias="floorCanvases",
+    )
+    created_at: datetime = Field(..., description="Timestamp when tenant was created")
+
+
+class TenantSummaryResponseDTO(BaseDTO):
+    id: EntityId = Field(..., description="Unique tenant identifier")
+    name: str = Field(..., description="Tenant name")
+    slug: str = Field(..., description="URL-friendly tenant identifier")
+    status: TenantStatus = Field(..., description="Tenant status")
+    active_layout_version_id: EntityId | None = Field(
+        None, alias="activeLayoutVersionId", serialization_alias="activeLayoutVersionId"
+    )
+    floor_canvas_count: int = Field(
+        ..., alias="floorCanvasCount", serialization_alias="floorCanvasCount"
+    )
+    created_at: datetime = Field(..., description="Timestamp when tenant was created")
diff --git a/app/api/routes/v1/health.py b/app/api/routes/v1/health.py
index d1a229d..952782f 100644
--- a/app/api/routes/v1/health.py
+++ b/app/api/routes/v1/health.py
@@ -1,11 +1,11 @@
-from fastapi import APIRouter
+from fastapi import APIRouter, status
 
 from core.foundation.database.connection import get_mongo_db, get_postgres_pool
 
 router = APIRouter()
 
 
-@router.get("")
+@router.get("", status_code=status.HTTP_200_OK)
 async def health_check() -> dict[str, str]:
     status = "healthy"
     mongodb_status = "up"
diff --git a/app/api/routes/v1/mappers/tenant_mappers.py b/app/api/routes/v1/mappers/tenant_mappers.py
new file mode 100644
index 0000000..1ba8f55
--- /dev/null
+++ b/app/api/routes/v1/mappers/tenant_mappers.py
@@ -0,0 +1,41 @@
+from core.dto.v1.floor_canvases import FloorCanvasResponseDTO
+from core.dto.v1.tenants import TenantResponseDTO, TenantSummaryResponseDTO
+from core.models import FloorCanvas, Tenant
+
+
+def tenant_to_response(tenant: Tenant) -> TenantResponseDTO:
+    return TenantResponseDTO(
+        id=tenant.id,
+        name=tenant.name,
+        slug=tenant.slug,
+        status=tenant.status,
+        activeLayoutVersionId=tenant.active_layout_version_id,
+        floorCanvases=[floor_canvas_to_response(fc) for fc in tenant.floor_canvases],
+        createdAt=tenant.created_at,
+    )
+
+
+def tenant_to_summary(tenant: Tenant) -> TenantSummaryResponseDTO:
+    return TenantSummaryResponseDTO(
+        id=tenant.id,
+        name=tenant.name,
+        slug=tenant.slug,
+        status=tenant.status,
+        activeLayoutVersionId=tenant.active_layout_version_id,
+        floorCanvasCount=len(tenant.floor_canvases),
+        createdAt=tenant.created_at,
+    )
+
+
+def floor_canvas_to_response(canvas: FloorCanvas) -> FloorCanvasResponseDTO:
+    return FloorCanvasResponseDTO(
+        id=canvas.id,
+        tenantId=canvas.tenant_id,
+        name=canvas.name,
+        width=canvas.width,
+        height=canvas.height,
+        elements=canvas.elements,
+        version=canvas.version,
+        createdAt=canvas.created_at,
+        updatedAt=canvas.updated_at,
+    )
diff --git a/app/api/routes/v1/orders.py b/app/api/routes/v1/orders.py
index 479b409..3ecae9e 100644
--- a/app/api/routes/v1/orders.py
+++ b/app/api/routes/v1/orders.py
@@ -2,9 +2,9 @@ from uuid import UUID
 
 from fastapi import APIRouter, status
 
-from api.v1.dto.orders import CreateOrderDTO, OrderResponseDTO, UpdateOrderDTO
-from core.foundation.http import MSG_NOT_IMPLEMENTED
-from core.foundation.http.schemas import (
+from core.dto.v1.orders import CreateOrderDTO, OrderResponseDTO, UpdateOrderDTO
+from core.foundation.http.consts import MSG_NOT_IMPLEMENTED
+from core.foundation.http.responses import (
     CreatedResponse,
     DeletedResponse,
     SuccessResponse,
@@ -14,7 +14,9 @@ from core.foundation.http.schemas import (
 router = APIRouter()
 
 
-@router.get("", status_code=status.HTTP_200_OK)
+@router.get(
+    "", status_code=status.HTTP_200_OK, response_model=SuccessResponse[list[OrderResponseDTO]]
+)
 async def list_orders() -> SuccessResponse[list[OrderResponseDTO]]:
     return SuccessResponse[list[OrderResponseDTO]](
         message="Orders retrieved successfully",
diff --git a/app/api/routes/v1/payments/create_payment.py b/app/api/routes/v1/payments/create_payment.py
index 8149ee8..8b4cdf5 100644
--- a/app/api/routes/v1/payments/create_payment.py
+++ b/app/api/routes/v1/payments/create_payment.py
@@ -1,55 +1,35 @@
-import base64
-import hashlib
-import json
 from typing import Any
 
 from fastapi import APIRouter, status
 
-from core.foundation.http.external_client import external_post_json
-from core.foundation.http.schemas import CreatedResponse
+from core.foundation.dependencies import ExternalClientDep, P24ServiceDep
+from core.foundation.http.responses import CreatedResponse
 from core.foundation.infra.config import settings
 from core.models import CreatePaymentRequest, Przelewy24RegisterRequest
 
 router = APIRouter()
 
-PRZELEWY24_SERVICE_NAME = "Przelewy24"
 
-
-def _przelewy24_sign(
-    session_id: str,
-    merchant_id: int,
-    amount: int,
-    currency: str,
-    crc: str,
-) -> str:
-    sign_data = {
-        "sessionId": session_id,
-        "merchantId": merchant_id,
-        "amount": amount,
-        "currency": currency,
-        "crc": crc,
-    }
-    payload = json.dumps(sign_data, separators=(",", ":"), ensure_ascii=False)
-    return hashlib.sha384(payload.encode("utf-8")).hexdigest()
-
-
-def _przelewy24_basic_auth() -> str:
-    raw = f"{settings.PRZELEWY24_MERCHANT_ID}:{settings.PRZELEWY24_API_KEY}"
-    return f"Basic {base64.b64encode(raw.encode('utf-8')).decode('utf-8')}"
-
-
-@router.post("", status_code=status.HTTP_201_CREATED)
-async def create_payment(request: CreatePaymentRequest) -> CreatedResponse[dict[str, Any]]:
-    sign = _przelewy24_sign(
+@router.post(
+    "",
+    status_code=status.HTTP_201_CREATED,
+    response_model=CreatedResponse[dict[str, Any]],
+)
+async def create_payment(
+    request: CreatePaymentRequest,
+    service: P24ServiceDep,
+    external_client: ExternalClientDep,
+) -> CreatedResponse[dict[str, Any]]:
+    sign = service._przelewy24_sign(
         session_id=request.session_id,
-        merchant_id=settings.PRZELEWY24_MERCHANT_ID,
+        merchant_id=service._merchant_id,
         amount=request.amount,
         currency=request.currency,
-        crc=settings.PRZELEWY24_CRC,
+        crc=service._crc,
     )
     body = Przelewy24RegisterRequest(
-        merchant_id=settings.PRZELEWY24_MERCHANT_ID,
-        pos_id=settings.PRZELEWY24_POS_ID,
+        merchant_id=service._merchant_id,
+        pos_id=service._pos_id,
         session_id=request.session_id,
         amount=request.amount,
         currency=request.currency,
@@ -65,12 +45,12 @@ async def create_payment(request: CreatePaymentRequest) -> CreatedResponse[dict[
     )
     request_data = body.model_dump(by_alias=True, exclude_none=True)
 
-    response_data = await external_post_json(
+    response_data = await external_client.external_post_json(
         f"{settings.PRZELEWY24_API_URL}/transaction/register",
         json=request_data,
-        headers={"Authorization": _przelewy24_basic_auth()},
+        headers={"Authorization": service._przelewy24_basic_auth()},
         timeout=30.0,
-        service_name=PRZELEWY24_SERVICE_NAME,
+        service_name=service._PRZELEWY24_SERVICE_NAME,
     )
 
     return CreatedResponse[dict[str, Any]](
diff --git a/app/api/routes/v1/payments/update_p24_config.py b/app/api/routes/v1/payments/update_p24_config.py
index c97592c..98799a3 100644
--- a/app/api/routes/v1/payments/update_p24_config.py
+++ b/app/api/routes/v1/payments/update_p24_config.py
@@ -3,11 +3,11 @@ from uuid import UUID
 from fastapi import APIRouter, HTTPException, status
 from sqlalchemy import select
 
-from api.v1.dto.payments import UpdateP24ConfigDTO
-from api.v1.dto.tenants import TenantResponseDTO
+from core.dto.v1.payments import UpdateP24ConfigDTO
+from core.dto.v1.tenants import TenantResponseDTO
 from core.foundation.dependencies import PostgresSession
-from core.foundation.http.schemas import UpdatedResponse
-from core.models import Tenant
+from core.foundation.http.responses import UpdatedResponse
+from core.models.tenant import Tenant
 
 router = APIRouter()
 
diff --git a/app/api/routes/v1/restaurants.py b/app/api/routes/v1/restaurants.py
index 2393d15..d26f3ee 100644
--- a/app/api/routes/v1/restaurants.py
+++ b/app/api/routes/v1/restaurants.py
@@ -2,13 +2,13 @@ from uuid import UUID
 
 from fastapi import APIRouter, status
 
-from api.v1.dto.restaurants import (
+from core.dto.v1.restaurants import (
     CreateRestaurantTableDTO,
     RestaurantTableResponseDTO,
     UpdateRestaurantTableDTO,
 )
-from core.foundation.http import MSG_NOT_IMPLEMENTED
-from core.foundation.http.schemas import (
+from core.foundation.http.consts import MSG_NOT_IMPLEMENTED
+from core.foundation.http.responses import (
     CreatedResponse,
     DeletedResponse,
     SuccessResponse,
diff --git a/app/api/routes/v1/tenants.py b/app/api/routes/v1/tenants.py
index e8470c5..b5046f0 100644
--- a/app/api/routes/v1/tenants.py
+++ b/app/api/routes/v1/tenants.py
@@ -2,45 +2,295 @@ from uuid import UUID
 
 from fastapi import APIRouter, status
 
-from api.v1.dto.tenants import CreateTenantDTO, TenantResponseDTO, UpdateTenantDTO
-from core.foundation.http import MSG_NOT_IMPLEMENTED
-from core.foundation.http.schemas import (
+from core.dto.v1 import (
+    CreateFloorCanvasDTO,
+    CreateTenantDTO,
+    FloorCanvasResponseDTO,
+    TenantResponseDTO,
+    TenantSummaryResponseDTO,
+    UpdateFloorCanvasDTO,
+    UpdateTenantDTO,
+)
+from core.foundation.dependencies import (
+    FloorCanvasServiceDep,
+    PostgresSession,
+    TenantServiceDep,
+)
+from core.foundation.http.responses import (
     CreatedResponse,
     DeletedResponse,
     SuccessResponse,
     UpdatedResponse,
 )
+from routes.v1.mappers.tenant_mappers import (
+    floor_canvas_to_response,
+    tenant_to_response,
+    tenant_to_summary,
+)
 
 router = APIRouter()
 
 
-@router.get("", status_code=status.HTTP_200_OK)
-async def list_tenants() -> SuccessResponse[list[TenantResponseDTO]]:
-    return SuccessResponse[list[TenantResponseDTO]](
+@router.get(
+    "/",
+    status_code=status.HTTP_200_OK,
+    response_model=SuccessResponse[list[TenantSummaryResponseDTO]],
+)
+async def list_tenants(
+    session: PostgresSession,
+    service: TenantServiceDep,
+) -> SuccessResponse[list[TenantSummaryResponseDTO]]:
+    tenants = await service.list_tenants(session)
+    return SuccessResponse(
         message="Tenants retrieved successfully",
-        data=[],
+        data=[tenant_to_summary(t) for t in tenants],
     )
 
 
-@router.get("/{tenant_id}", status_code=status.HTTP_200_OK)
-async def get_tenant(tenant_id: UUID) -> SuccessResponse[TenantResponseDTO]:
-    raise NotImplementedError(MSG_NOT_IMPLEMENTED)
+@router.post(
+    "/",
+    status_code=status.HTTP_201_CREATED,
+    response_model=CreatedResponse[TenantResponseDTO],
+)
+async def create_tenant(
+    request: CreateTenantDTO,
+    session: PostgresSession,
+    service: TenantServiceDep,
+) -> CreatedResponse[TenantResponseDTO]:
+    data = CreateTenantDTO(
+        name=request.name,
+        slug=request.slug,
+        status=request.status,
+    )
+    tenant = await service.create_tenant(session, data)
+    return CreatedResponse(
+        message="Tenant created successfully",
+        data=tenant_to_response(tenant),
+    )
 
 
-@router.post("", status_code=status.HTTP_201_CREATED)
-async def create_tenant(request: CreateTenantDTO) -> CreatedResponse[TenantResponseDTO]:
-    raise NotImplementedError(MSG_NOT_IMPLEMENTED)
+@router.get(
+    "/{tenant_id}",
+    status_code=status.HTTP_200_OK,
+    response_model=SuccessResponse[TenantResponseDTO],
+    summary="Get a tenant by ID",
+    description="Get a tenant by ID",
+    response_description="Tenant retrieved successfully",
+)
+async def get_tenant(
+    tenant_id: UUID,
+    session: PostgresSession,
+    service: TenantServiceDep,
+) -> SuccessResponse[TenantResponseDTO]:
+    tenant = await service.get_tenant(session, tenant_id)
+    return SuccessResponse(
+        message="Tenant retrieved successfully",
+        data=tenant_to_response(tenant),
+    )
 
 
-@router.put("/{tenant_id}", status_code=status.HTTP_200_OK)
+@router.put(
+    "/{tenant_id}",
+    status_code=status.HTTP_200_OK,
+    response_model=UpdatedResponse[TenantResponseDTO],
+    summary="Update a tenant",
+    description="Update a tenant",
+    response_description="Tenant updated successfully",
+)
 async def update_tenant(
-    tenant_id: UUID, request: UpdateTenantDTO
+    tenant_id: UUID,
+    request: UpdateTenantDTO,
+    session: PostgresSession,
+    service: TenantServiceDep,
 ) -> UpdatedResponse[TenantResponseDTO]:
-    raise NotImplementedError(MSG_NOT_IMPLEMENTED)
+    data = UpdateTenantDTO(
+        name=request.name,
+        slug=request.slug,
+        status=request.status,
+        active_layout_version_id=request.active_layout_version_id,
+    )
+    tenant = await service.update_tenant(session, tenant_id, data)
+    return UpdatedResponse(
+        message="Tenant updated successfully",
+        data=tenant_to_response(tenant),
+    )
+
+
+@router.delete(
+    "/{tenant_id}",
+    status_code=status.HTTP_200_OK,
+    response_model=DeletedResponse,
+    summary="Delete a tenant",
+    description="Delete a tenant",
+    response_description="Tenant deleted successfully",
+)
+async def delete_tenant(
+    tenant_id: UUID,
+    session: PostgresSession,
+    service: TenantServiceDep,
+) -> DeletedResponse:
+    await service.delete_tenant(session, tenant_id)
+    return DeletedResponse(message=f"Tenant {tenant_id} deleted successfully")
+
+
+@router.get(
+    "/{tenant_id}/canvases",
+    status_code=status.HTTP_200_OK,
+    response_model=SuccessResponse[list[FloorCanvasResponseDTO]],
+    summary="List floor canvases",
+    description="List floor canvases",
+    response_description="Floor canvases retrieved successfully",
+)
+async def list_floor_canvases(
+    tenant_id: UUID,
+    session: PostgresSession,
+    service: FloorCanvasServiceDep,
+) -> SuccessResponse[list[FloorCanvasResponseDTO]]:
+    canvases = await service.list_canvases(session, tenant_id)
+    return SuccessResponse(
+        message="Floor canvases retrieved successfully",
+        data=[floor_canvas_to_response(c) for c in canvases],
+    )
+
+
+@router.get(
+    "/{tenant_id}/canvases/{canvas_id}",
+    status_code=status.HTTP_200_OK,
+    response_model=SuccessResponse[FloorCanvasResponseDTO],
+    summary="Get a floor canvas by ID",
+    description="Get a floor canvas by ID",
+    response_description="Floor canvas retrieved successfully",
+)
+async def get_floor_canvas(
+    tenant_id: UUID,
+    canvas_id: UUID,
+    session: PostgresSession,
+    service: FloorCanvasServiceDep,
+) -> SuccessResponse[FloorCanvasResponseDTO]:
+    canvas = await service.get_canvas(session, tenant_id, canvas_id)
+    return SuccessResponse(
+        message="Floor canvas retrieved successfully",
+        data=floor_canvas_to_response(canvas),
+    )
+
 
+@router.post(
+    "/{tenant_id}/canvases",
+    status_code=status.HTTP_201_CREATED,
+    response_model=CreatedResponse[FloorCanvasResponseDTO],
+    summary="Create a floor canvas",
+    description="Create a floor canvas",
+    response_description="Floor canvas created successfully",
+)
+async def create_floor_canvas(
+    tenant_id: UUID,
+    request: CreateFloorCanvasDTO,
+    session: PostgresSession,
+    service: FloorCanvasServiceDep,
+) -> CreatedResponse[FloorCanvasResponseDTO]:
+    data = CreateFloorCanvasDTO(
+        name=request.name,
+        width=request.width,
+        height=request.height,
+        elements=[el.model_dump(by_alias=True, exclude_none=True) for el in request.elements],
+    )
+    canvas = await service.create_canvas(session, tenant_id, data)
+    return CreatedResponse(
+        message="Floor canvas created successfully",
+        data=floor_canvas_to_response(canvas),
+    )
 
-@router.delete("/{tenant_id}", status_code=status.HTTP_200_OK)
-async def delete_tenant(tenant_id: UUID) -> DeletedResponse:
-    return DeletedResponse(
-        message=f"Tenant {tenant_id} deleted successfully",
+
+@router.put(
+    "/{tenant_id}/canvases/{canvas_id}",
+    status_code=status.HTTP_200_OK,
+    response_model=UpdatedResponse[FloorCanvasResponseDTO],
+    response_model_exclude_none=True,
+    summary="Update a floor canvas",
+    description="Update a floor canvas",
+    response_description="Floor canvas updated successfully",
+)
+async def update_floor_canvas(
+    tenant_id: UUID,
+    canvas_id: UUID,
+    request: UpdateFloorCanvasDTO,
+    session: PostgresSession,
+    service: FloorCanvasServiceDep,
+) -> UpdatedResponse[FloorCanvasResponseDTO]:
+    elements = None
+    if request.elements is not None:
+        elements = [el.model_dump(by_alias=True, exclude_none=True) for el in request.elements]
+
+    data = UpdateFloorCanvasDTO(
+        name=request.name,
+        width=request.width,
+        height=request.height,
+        elements=elements,
+    )
+    canvas = await service.update_canvas(session, tenant_id, canvas_id, data)
+    return UpdatedResponse(
+        message="Floor canvas updated successfully",
+        data=floor_canvas_to_response(canvas),
+    )
+
+
+@router.delete(
+    "/{tenant_id}/canvases/{canvas_id}",
+    status_code=status.HTTP_200_OK,
+    response_model=DeletedResponse,
+    summary="Delete a floor canvas",
+    description="Delete a floor canvas",
+    response_description="Floor canvas deleted successfully",
+)
+async def delete_floor_canvas(
+    tenant_id: UUID,
+    canvas_id: UUID,
+    session: PostgresSession,
+    service: FloorCanvasServiceDep,
+) -> DeletedResponse:
+    await service.delete_canvas(session, tenant_id, canvas_id)
+    return DeletedResponse(message=f"Floor canvas {canvas_id} deleted successfully")
+
+
+@router.get(
+    "/{tenant_id}/canvases/{canvas_id}/versions",
+    status_code=status.HTTP_200_OK,
+    response_model=SuccessResponse[list[dict]],
+    summary="List canvas versions",
+    description="List canvas versions",
+    response_description="Canvas versions retrieved successfully",
+)
+async def list_canvas_versions(
+    tenant_id: UUID,
+    canvas_id: UUID,
+    session: PostgresSession,
+    service: FloorCanvasServiceDep,
+    limit: int = 50,
+) -> SuccessResponse[list[dict]]:
+    versions = await service.list_versions(session, tenant_id, canvas_id, limit)
+    return SuccessResponse(
+        message="Canvas versions retrieved successfully",
+        data=versions,
+    )
+
+
+@router.get(
+    "/{tenant_id}/canvases/{canvas_id}/versions/{version}",
+    status_code=status.HTTP_200_OK,
+    response_model=SuccessResponse[dict],
+    summary="Get a canvas version by ID",
+    description="Get a canvas version by ID",
+    response_description="Canvas version retrieved successfully",
+)
+async def get_canvas_version(
+    tenant_id: UUID,
+    canvas_id: UUID,
+    version: int,
+    session: PostgresSession,
+    service: FloorCanvasServiceDep,
+) -> SuccessResponse[dict]:
+    version_data = await service.get_version(session, tenant_id, canvas_id, version)
+    return SuccessResponse(
+        message="Canvas version retrieved successfully",
+        data=version_data,
     )
diff --git a/app/api/routes/v1/venues.py b/app/api/routes/v1/venues.py
deleted file mode 100644
index 897817b..0000000
--- a/app/api/routes/v1/venues.py
+++ /dev/null
@@ -1,302 +0,0 @@
-from uuid import UUID
-
-from fastapi import APIRouter, HTTPException, status
-from sqlalchemy import select
-from sqlalchemy.orm import selectinload
-
-from api.v1.dto.venues import (
-    CreateFloorCanvasDTO,
-    CreateVenueDTO,
-    FloorCanvasResponseDTO,
-    UpdateFloorCanvasDTO,
-    UpdateVenueDTO,
-    VenueResponseDTO,
-    VenueSummaryResponseDTO,
-)
-from core.foundation.dependencies import PostgresSession
-from core.foundation.http.schemas import (
-    CreatedResponse,
-    DeletedResponse,
-    SuccessResponse,
-    UpdatedResponse,
-)
-from core.models import FloorCanvas, Venue
-
-router = APIRouter()
-
-
-def venue_to_response(venue: Venue) -> VenueResponseDTO:
-    return VenueResponseDTO(
-        id=venue.id,
-        tenantId=venue.tenant_id,
-        name=venue.name,
-        activeLayoutVersionId=venue.active_layout_version_id,
-        floorCanvases=[floor_canvas_to_response(fc) for fc in venue.floor_canvases],
-        createdAt=venue.created_at,
-        updatedAt=venue.updated_at,
-    )
-
-
-def venue_to_summary(venue: Venue) -> VenueSummaryResponseDTO:
-    return VenueSummaryResponseDTO(
-        id=venue.id,
-        tenantId=venue.tenant_id,
-        name=venue.name,
-        activeLayoutVersionId=venue.active_layout_version_id,
-        floorCanvasCount=len(venue.floor_canvases),
-        createdAt=venue.created_at,
-        updatedAt=venue.updated_at,
-    )
-
-
-def floor_canvas_to_response(canvas: FloorCanvas) -> FloorCanvasResponseDTO:
-    return FloorCanvasResponseDTO(
-        id=canvas.id,
-        venueId=canvas.venue_id,
-        name=canvas.name,
-        width=canvas.width,
-        height=canvas.height,
-        elements=canvas.elements,
-        version=canvas.version,
-        createdAt=canvas.created_at,
-        updatedAt=canvas.updated_at,
-    )
-
-
-@router.get("", status_code=status.HTTP_200_OK)
-@router.get("/list", status_code=status.HTTP_200_OK)
-async def list_venues(
-    session: PostgresSession,
-    tenant_id: UUID | None = None,
-) -> SuccessResponse[list[VenueSummaryResponseDTO]]:
-    query = select(Venue).options(selectinload(Venue.floor_canvases))
-    if tenant_id:
-        query = query.where(Venue.tenant_id == tenant_id)
-    query = query.order_by(Venue.created_at.desc())
-
-    result = await session.execute(query)
-    venues = result.scalars().all()
-
-    return SuccessResponse[list[VenueSummaryResponseDTO]](
-        message="Venues retrieved successfully",
-        data=[venue_to_summary(v) for v in venues],
-    )
-
-
-@router.get("/{venue_id}", status_code=status.HTTP_200_OK)
-async def get_venue(
-    venue_id: UUID,
-    session: PostgresSession,
-) -> SuccessResponse[VenueResponseDTO]:
-    query = select(Venue).options(selectinload(Venue.floor_canvases)).where(Venue.id == venue_id)
-    result = await session.execute(query)
-    venue = result.scalar_one_or_none()
-
-    if not venue:
-        raise HTTPException(status_code=404, detail=f"Venue {venue_id} not found")
-
-    return SuccessResponse[VenueResponseDTO](
-        message="Venue retrieved successfully",
-        data=venue_to_response(venue),
-    )
-
-
-@router.post("/{tenant_id}", status_code=status.HTTP_201_CREATED)
-async def create_venue(
-    tenant_id: UUID,
-    request: CreateVenueDTO,
-    session: PostgresSession,
-) -> CreatedResponse[VenueResponseDTO]:
-    venue = Venue(
-        tenant_id=tenant_id,
-        name=request.name,
-    )
-    session.add(venue)
-    await session.commit()
-    await session.refresh(venue, attribute_names=["floor_canvases"])
-
-    return CreatedResponse[VenueResponseDTO](
-        message="Venue created successfully",
-        data=venue_to_response(venue),
-    )
-
-
-@router.put("/{venue_id}", status_code=status.HTTP_200_OK)
-async def update_venue(
-    venue_id: UUID,
-    request: UpdateVenueDTO,
-    session: PostgresSession,
-) -> UpdatedResponse[VenueResponseDTO]:
-    query = select(Venue).options(selectinload(Venue.floor_canvases)).where(Venue.id == venue_id)
-    result = await session.execute(query)
-    venue = result.scalar_one_or_none()
-
-    if not venue:
-        raise HTTPException(status_code=404, detail=f"Venue {venue_id} not found")
-
-    if request.name is not None:
-        venue.name = request.name
-    if request.active_layout_version_id is not None:
-        venue.active_layout_version_id = request.active_layout_version_id
-
-    await session.commit()
-    await session.refresh(venue, attribute_names=["floor_canvases"])
-
-    return UpdatedResponse[VenueResponseDTO](
-        message="Venue updated successfully",
-        data=venue_to_response(venue),
-    )
-
-
-@router.delete("/{venue_id}", status_code=status.HTTP_200_OK)
-async def delete_venue(
-    venue_id: UUID,
-    session: PostgresSession,
-) -> DeletedResponse:
-    query = select(Venue).where(Venue.id == venue_id)
-    result = await session.execute(query)
-    venue = result.scalar_one_or_none()
-
-    if not venue:
-        raise HTTPException(status_code=404, detail=f"Venue {venue_id} not found")
-
-    await session.delete(venue)
-    await session.commit()
-
-    return DeletedResponse(message=f"Venue {venue_id} deleted successfully")
-
-
-@router.get("/{venue_id}/canvases", status_code=status.HTTP_200_OK)
-async def list_floor_canvases(
-    venue_id: UUID,
-    session: PostgresSession,
-) -> SuccessResponse[list[FloorCanvasResponseDTO]]:
-    venue_query = select(Venue).where(Venue.id == venue_id)
-    venue_result = await session.execute(venue_query)
-    if not venue_result.scalar_one_or_none():
-        raise HTTPException(status_code=404, detail=f"Venue {venue_id} not found")
-
-    query = (
-        select(FloorCanvas)
-        .where(FloorCanvas.venue_id == venue_id)
-        .order_by(FloorCanvas.created_at.desc())
-    )
-    result = await session.execute(query)
-    canvases = result.scalars().all()
-
-    return SuccessResponse[list[FloorCanvasResponseDTO]](
-        message="Floor canvases retrieved successfully",
-        data=[floor_canvas_to_response(c) for c in canvases],
-    )
-
-
-@router.get("/{venue_id}/canvases/{canvas_id}", status_code=status.HTTP_200_OK)
-async def get_floor_canvas(
-    venue_id: UUID,
-    canvas_id: UUID,
-    session: PostgresSession,
-) -> SuccessResponse[FloorCanvasResponseDTO]:
-    query = select(FloorCanvas).where(
-        FloorCanvas.id == canvas_id,
-        FloorCanvas.venue_id == venue_id,
-    )
-    result = await session.execute(query)
-    canvas = result.scalar_one_or_none()
-
-    if not canvas:
-        raise HTTPException(status_code=404, detail=f"Floor canvas {canvas_id} not found")
-
-    return SuccessResponse[FloorCanvasResponseDTO](
-        message="Floor canvas retrieved successfully",
-        data=floor_canvas_to_response(canvas),
-    )
-
-
-@router.post("/{venue_id}/canvases", status_code=status.HTTP_201_CREATED)
-async def create_floor_canvas(
-    venue_id: UUID,
-    request: CreateFloorCanvasDTO,
-    session: PostgresSession,
-) -> CreatedResponse[FloorCanvasResponseDTO]:
-    venue_query = select(Venue).where(Venue.id == venue_id)
-    venue_result = await session.execute(venue_query)
-    if not venue_result.scalar_one_or_none():
-        raise HTTPException(status_code=404, detail=f"Venue {venue_id} not found")
-
-    elements_data = [el.model_dump(by_alias=True, exclude_none=True) for el in request.elements]
-
-    canvas = FloorCanvas(
-        venue_id=venue_id,
-        name=request.name,
-        width=request.width,
-        height=request.height,
-        elements=elements_data,
-    )
-    session.add(canvas)
-    await session.commit()
-    await session.refresh(canvas)
-
-    return CreatedResponse[FloorCanvasResponseDTO](
-        message="Floor canvas created successfully",
-        data=floor_canvas_to_response(canvas),
-    )
-
-
-@router.put("/{venue_id}/canvases/{canvas_id}", status_code=status.HTTP_200_OK)
-async def update_floor_canvas(
-    venue_id: UUID,
-    canvas_id: UUID,
-    request: UpdateFloorCanvasDTO,
-    session: PostgresSession,
-) -> UpdatedResponse[FloorCanvasResponseDTO]:
-    query = select(FloorCanvas).where(
-        FloorCanvas.id == canvas_id,
-        FloorCanvas.venue_id == venue_id,
-    )
-    result = await session.execute(query)
-    canvas = result.scalar_one_or_none()
-
-    if not canvas:
-        raise HTTPException(status_code=404, detail=f"Floor canvas {canvas_id} not found")
-
-    if request.name is not None:
-        canvas.name = request.name
-    if request.width is not None:
-        canvas.width = request.width
-    if request.height is not None:
-        canvas.height = request.height
-    if request.elements is not None:
-        canvas.elements = [
-            el.model_dump(by_alias=True, exclude_none=True) for el in request.elements
-        ]
-        canvas.version += 1
-
-    await session.commit()
-    await session.refresh(canvas)
-
-    return UpdatedResponse[FloorCanvasResponseDTO](
-        message="Floor canvas updated successfully",
-        data=floor_canvas_to_response(canvas),
-    )
-
-
-@router.delete("/{venue_id}/canvases/{canvas_id}", status_code=status.HTTP_200_OK)
-async def delete_floor_canvas(
-    venue_id: UUID,
-    canvas_id: UUID,
-    session: PostgresSession,
-) -> DeletedResponse:
-    query = select(FloorCanvas).where(
-        FloorCanvas.id == canvas_id,
-        FloorCanvas.venue_id == venue_id,
-    )
-    result = await session.execute(query)
-    canvas = result.scalar_one_or_none()
-
-    if not canvas:
-        raise HTTPException(status_code=404, detail=f"Floor canvas {canvas_id} not found")
-
-    await session.delete(canvas)
-    await session.commit()
-
-    return DeletedResponse(message=f"Floor canvas {canvas_id} deleted successfully")
diff --git a/app/api/services/auth_service.py b/app/api/services/auth_service.py
new file mode 100644
index 0000000..4c4a087
--- /dev/null
+++ b/app/api/services/auth_service.py
@@ -0,0 +1,115 @@
+from datetime import UTC, datetime, timedelta
+from uuid import UUID
+
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from core.exceptions import (
+    BadRequestError,
+    GoneError,
+    NotFoundError,
+    TooManyRequestsError,
+)
+from core.foundation.security import SecurityService
+from core.models.activation_link import ActivationLink
+from core.models.enums import TenantStatus
+from core.models.tenant import Tenant
+from core.models.user import User
+
+
+class AuthService:
+    def __init__(self, security: SecurityService) -> None:
+        self._resend_cooldown_seconds = 300
+        self.security = security
+
+    async def create_activation_link(
+        self,
+        session: AsyncSession,
+        email: str,
+        user_id: UUID,
+        tenant_id: UUID,
+    ) -> ActivationLink:
+        activation_link = ActivationLink(
+            email=email,
+            user_id=user_id,
+            tenant_id=tenant_id,
+            expires_at=datetime.now(tz=UTC) + timedelta(hours=24),
+        )
+        session.add(activation_link)
+        await session.flush()
+        await session.refresh(activation_link)
+        return activation_link
+
+    async def activate_account(
+        self,
+        session: AsyncSession,
+        activation_id: UUID,
+    ) -> tuple[Tenant, bool]:
+        """Returns (tenant, already_activated)."""
+        activation_link = await session.get(ActivationLink, activation_id)
+        if activation_link is None:
+            msg = "Activation link not found"
+            raise NotFoundError(msg, str(activation_id))
+
+        now = datetime.now(tz=UTC)
+        if activation_link.expires_at < now:
+            msg = "Activation link has expired"
+            raise GoneError(msg)
+
+        tenant = await session.get(Tenant, activation_link.tenant_id)
+        if tenant is None:
+            msg = "Account"
+            raise NotFoundError(msg, "activation link")
+
+        if activation_link.used_at is not None:
+            return tenant, True
+
+        user = await session.get(User, activation_link.user_id)
+        if user is None:
+            msg = "Account"
+            raise NotFoundError(msg, "activation link")
+        user.is_active = True
+        tenant.status = TenantStatus.ACTIVE
+        activation_link.used_at = now
+        return tenant, False
+
+    async def resend_activation_link(
+        self,
+        session: AsyncSession,
+        activation_id: UUID,
+    ) -> tuple[ActivationLink, Tenant]:
+        """Resend only when link is expired. Cooldown is per activation link (last_resend_at)."""
+        activation_link = await session.get(ActivationLink, activation_id)
+        if activation_link is None:
+            msg = "Activation link"
+            raise NotFoundError(msg, str(activation_id))
+
+        now = datetime.now(tz=UTC)
+        if activation_link.used_at is not None:
+            msg = "Account already activated"
+            raise BadRequestError(msg)
+        if activation_link.expires_at >= now:
+            msg = "Activation link has not expired yet"
+            raise BadRequestError(msg)
+
+        if activation_link.last_resend_at is not None:
+            elapsed = (now - activation_link.last_resend_at).total_seconds()
+            if elapsed < self._resend_cooldown_seconds:
+                msg = "Please wait before requesting another activation email."
+                raise TooManyRequestsError(msg)
+
+        activation_link.last_resend_at = now
+        tenant = await session.get(Tenant, activation_link.tenant_id)
+        if tenant is None:
+            msg = "Account"
+            raise NotFoundError(msg, "activation link")
+
+        new_link = ActivationLink(
+            email=activation_link.email,
+            user_id=activation_link.user_id,
+            tenant_id=activation_link.tenant_id,
+            expires_at=now + timedelta(hours=24),
+        )
+        session.add(new_link)
+        await session.flush()
+        await session.refresh(new_link)
+        return new_link, tenant
diff --git a/app/api/services/canvas_versioning.py b/app/api/services/canvas_versioning.py
new file mode 100644
index 0000000..965a949
--- /dev/null
+++ b/app/api/services/canvas_versioning.py
@@ -0,0 +1,50 @@
+from __future__ import annotations
+
+from datetime import datetime, timezone
+from typing import Any
+from uuid import UUID
+
+from core.foundation.database.connection import get_mongo_db
+from core.models.floor_canvas import FloorCanvas
+
+
+async def archive_canvas_version(canvas: FloorCanvas) -> None:
+    db = get_mongo_db()
+    collection = db["canvas_versions"]
+
+    version_doc = {
+        "canvas_id": str(canvas.id),
+        "tenant_id": str(canvas.tenant_id),
+        "version": canvas.version,
+        "name": canvas.name,
+        "width": canvas.width,
+        "height": canvas.height,
+        "elements": canvas.elements,
+        "created_at": canvas.created_at.isoformat(),
+        "updated_at": canvas.updated_at.isoformat(),
+        "archived_at": datetime.now(timezone.UTC).isoformat(),
+    }
+
+    await collection.insert_one(version_doc)
+
+
+async def get_canvas_version(canvas_id: UUID, version: int) -> dict[str, Any] | None:
+    db = get_mongo_db()
+    collection = db["canvas_versions"]
+
+    return await collection.find_one(
+        {"canvas_id": str(canvas_id), "version": version},
+        sort=[("archived_at", -1)],
+    )
+
+
+async def get_canvas_versions(canvas_id: UUID, limit: int = 50) -> list[dict[str, Any]]:
+    db = get_mongo_db()
+    collection = db["canvas_versions"]
+
+    cursor = collection.find(
+        {"canvas_id": str(canvas_id)},
+        sort=[("version", -1)],
+    ).limit(limit)
+
+    return await cursor.to_list(length=limit)
diff --git a/app/api/services/email_service.py b/app/api/services/email_service.py
new file mode 100644
index 0000000..4a6fe3b
--- /dev/null
+++ b/app/api/services/email_service.py
@@ -0,0 +1,154 @@
+from __future__ import annotations
+
+import asyncio
+from datetime import UTC, datetime, timedelta
+from uuid import UUID
+
+import resend
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from core.exceptions import (
+    BadRequestError,
+    GoneError,
+    NotFoundError,
+    TooManyRequestsError,
+)
+from core.foundation.infra.config import settings
+from core.models.activation_link import ActivationLink
+from core.models.enums import TenantStatus
+from core.models.tenant import Tenant
+from core.models.user import User
+
+
+class EmailService:
+    def __init__(self) -> None:
+        self._resend_api_key = settings.RESEND_API_KEY.strip()
+        self._resend_from_email = settings.RESEND_FROM_EMAIL.strip()
+
+    def _get_resend_settings(self) -> tuple[str, str]:
+        if not self._resend_api_key:
+            msg = "RESEND_API_KEY is required to send emails."
+            raise RuntimeError(msg)
+        if not self._resend_from_email:
+            msg = "RESEND_FROM_EMAIL is required to send emails."
+            raise RuntimeError(msg)
+        return self._resend_api_key, self._resend_from_email
+
+    async def send_activation_email(
+        self,
+        to_email: str,
+        restaurant_name: str,
+        activation_link: str,
+    ) -> None:
+        resend_api_key, resend_from_email = self._get_resend_settings()
+        resend.api_key = resend_api_key
+
+        subject = f"Activate your {restaurant_name} account"
+        html = f"""
+        <p>Welcome to Restorio, {restaurant_name}!</p>
+        <p>Please activate your account:</p>
+        <p><a href="{activation_link}">Activate my account</a></p>
+        """
+
+        await asyncio.to_thread(
+            resend.Emails.send,
+            {
+                "from": resend_from_email,
+                "to": [to_email],
+                "subject": subject,
+                "html": html,
+            },
+        )
+
+    async def create_activation_link(
+        self,
+        session: AsyncSession,
+        email: str,
+        user_id: UUID,
+        tenant_id: UUID,
+    ) -> ActivationLink:
+        activation_link = ActivationLink(
+            email=email,
+            user_id=user_id,
+            tenant_id=tenant_id,
+            expires_at=datetime.now(tz=UTC) + timedelta(hours=24),
+        )
+        session.add(activation_link)
+        await session.flush()
+        await session.refresh(activation_link)
+        return activation_link
+
+    async def activate_account(
+        self,
+        session: AsyncSession,
+        activation_id: UUID,
+    ) -> tuple[Tenant, bool]:
+        """Returns (tenant, already_activated)."""
+        activation_link = await session.get(ActivationLink, activation_id)
+        if activation_link is None:
+            msg = "Activation link not found"
+            raise NotFoundError(msg, str(activation_id))
+
+        now = datetime.now(tz=UTC)
+        if activation_link.expires_at < now:
+            msg = "Activation link has expired"
+            raise GoneError(msg)
+
+        tenant = await session.get(Tenant, activation_link.tenant_id)
+        if tenant is None:
+            msg = "Account"
+            raise NotFoundError(msg, "activation link")
+
+        if activation_link.used_at is not None:
+            return tenant, True
+
+        user = await session.get(User, activation_link.user_id)
+        if user is None:
+            msg = "Account"
+            raise NotFoundError(msg, "activation link")
+        user.is_active = True
+        tenant.status = TenantStatus.ACTIVE
+        activation_link.used_at = now
+        return tenant, False
+
+    async def resend_activation_link(
+        self,
+        session: AsyncSession,
+        activation_id: UUID,
+    ) -> tuple[ActivationLink, Tenant]:
+        """Resend only when link is expired. Cooldown is per activation link (last_resend_at)."""
+        activation_link = await session.get(ActivationLink, activation_id)
+        if activation_link is None:
+            msg = "Activation link"
+            raise NotFoundError(msg, str(activation_id))
+
+        now = datetime.now(tz=UTC)
+        if activation_link.used_at is not None:
+            msg = "Account already activated"
+            raise BadRequestError(msg)
+        if activation_link.expires_at >= now:
+            msg = "Activation link has not expired yet"
+            raise BadRequestError(msg)
+
+        if activation_link.last_resend_at is not None:
+            elapsed = (now - activation_link.last_resend_at).total_seconds()
+            if elapsed < self._resend_cooldown_seconds:
+                msg = "Please wait before requesting another activation email."
+                raise TooManyRequestsError(msg)
+
+        activation_link.last_resend_at = now
+        tenant = await session.get(Tenant, activation_link.tenant_id)
+        if tenant is None:
+            msg = "Account"
+            raise NotFoundError(msg, "activation link")
+
+        new_link = ActivationLink(
+            email=activation_link.email,
+            user_id=activation_link.user_id,
+            tenant_id=activation_link.tenant_id,
+            expires_at=now + timedelta(hours=24),
+        )
+        session.add(new_link)
+        await session.flush()
+        await session.refresh(new_link)
+        return new_link, tenant
diff --git a/app/api/services/external_client_service.py b/app/api/services/external_client_service.py
new file mode 100644
index 0000000..35fb61c
--- /dev/null
+++ b/app/api/services/external_client_service.py
@@ -0,0 +1,73 @@
+from __future__ import annotations
+
+from typing import Any
+
+import httpx
+
+from core.exceptions import ExternalAPIError, ServiceUnavailableError
+
+
+class ExternalClient:
+    def __init__(self) -> None:
+        self._client = httpx.AsyncClient()
+
+    async def post_json(
+        self,
+        url: str,
+        *,
+        json: dict[str, Any],
+        headers: dict[str, str] | None = None,
+        timeout: float = 30.0,
+    ) -> dict[str, Any]:
+        merged_headers = {"Content-Type": "application/json", **(headers or {})}
+        response = await self._client.post(url, json=json, headers=merged_headers, timeout=timeout)
+        response.raise_for_status()
+        return response.json()
+
+    async def external_post_json(
+        self,
+        url: str,
+        *,
+        json: dict[str, Any],
+        headers: dict[str, str] | None = None,
+        timeout: float = 30.0,
+        service_name: str = "External API",
+    ) -> dict[str, Any]:
+        """POST JSON to an external API. Returns parsed JSON on success.
+        Raises ExternalAPIError on 4xx/5xx, ServiceUnavailableError on connection/timeout.
+        """
+        merged_headers = {"Content-Type": "application/json", **(headers or {})}
+        async with httpx.AsyncClient() as client:
+            try:
+                response = await client.post(
+                    url,
+                    json=json,
+                    headers=merged_headers,
+                    timeout=timeout,
+                )
+                response.raise_for_status()
+                return response.json()
+            except httpx.HTTPStatusError as e:
+                error_message = self._extract_error_message(e)
+                raise ExternalAPIError(
+                    status_code=e.response.status_code,
+                    message=f"{service_name} error: {error_message}",
+                ) from e
+            except httpx.RequestError as e:
+                raise ServiceUnavailableError(
+                    message=f"Failed to connect to {service_name}: {e!s}",
+                ) from e
+
+    @staticmethod
+    def _extract_error_message(e: httpx.HTTPStatusError) -> str:
+        try:
+            body = e.response.json()
+            if isinstance(body, dict):
+                inner = body.get("error") or body.get("errors") or body
+                if isinstance(inner, dict) and "message" in inner:
+                    return str(inner["message"])
+                if isinstance(inner, str):
+                    return inner
+            return e.response.text or str(e)
+        except Exception:
+            return e.response.text or str(e)
diff --git a/app/api/services/floor_canvas_service.py b/app/api/services/floor_canvas_service.py
new file mode 100644
index 0000000..5bf483d
--- /dev/null
+++ b/app/api/services/floor_canvas_service.py
@@ -0,0 +1,138 @@
+from typing import Any
+from uuid import UUID
+
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from core.dto.v1.floor_canvases import CreateFloorCanvasDTO, UpdateFloorCanvasDTO
+from core.exceptions import NotFoundError
+from core.models import FloorCanvas, Tenant
+from services.canvas_versioning import (
+    archive_canvas_version,
+    get_canvas_versions,
+)
+from services.canvas_versioning import (
+    get_canvas_version as get_archived_version,
+)
+
+
+class FloorCanvasService:
+    _RESOURCE = "Floor canvas"
+    _RESOURCE_VERSION = "Canvas version"
+
+    async def list_canvases(self, session: AsyncSession, tenant_id: UUID) -> list[FloorCanvas]:
+        await self._ensure_tenant_exists(session, tenant_id)
+
+        query = (
+            select(FloorCanvas)
+            .where(FloorCanvas.tenant_id == tenant_id)
+            .order_by(FloorCanvas.created_at.desc())
+        )
+        result = await session.execute(query)
+        return list(result.scalars().all())
+
+    async def get_canvas(
+        self, session: AsyncSession, tenant_id: UUID, canvas_id: UUID
+    ) -> FloorCanvas:
+        query = select(FloorCanvas).where(
+            FloorCanvas.id == canvas_id,
+            FloorCanvas.tenant_id == tenant_id,
+        )
+        result = await session.execute(query)
+        canvas = result.scalar_one_or_none()
+
+        if not canvas:
+            raise NotFoundError(self._RESOURCE, str(canvas_id))
+
+        return canvas
+
+    async def create_canvas(
+        self, session: AsyncSession, tenant_id: UUID, data: CreateFloorCanvasDTO
+    ) -> FloorCanvas:
+        await self._ensure_tenant_exists(session, tenant_id)
+
+        canvas = FloorCanvas(
+            tenant_id=tenant_id,
+            name=data.name,
+            width=data.width,
+            height=data.height,
+            elements=data.elements,
+        )
+        session.add(canvas)
+        await session.commit()
+        await session.refresh(canvas)
+        return canvas
+
+    async def update_canvas(
+        self,
+        session: AsyncSession,
+        tenant_id: UUID,
+        canvas_id: UUID,
+        data: UpdateFloorCanvasDTO,
+    ) -> FloorCanvas:
+        canvas = await self.get_canvas(session, tenant_id, canvas_id)
+
+        if data.elements is not None:
+            await archive_canvas_version(canvas)
+            canvas.elements = data.elements
+            canvas.version += 1
+
+        if data.name is not None:
+            canvas.name = data.name
+        if data.width is not None:
+            canvas.width = data.width
+        if data.height is not None:
+            canvas.height = data.height
+
+        await session.commit()
+        await session.refresh(canvas)
+        return canvas
+
+    async def delete_canvas(self, session: AsyncSession, tenant_id: UUID, canvas_id: UUID) -> None:
+        canvas = await self.get_canvas(session, tenant_id, canvas_id)
+        await session.delete(canvas)
+        await session.commit()
+
+    async def list_versions(
+        self, session: AsyncSession, tenant_id: UUID, canvas_id: UUID, limit: int = 50
+    ) -> list[dict[str, Any]]:
+        await self.get_canvas(session, tenant_id, canvas_id)
+        return await get_canvas_versions(canvas_id, limit=limit)
+
+    async def get_version(
+        self,
+        session: AsyncSession,
+        tenant_id: UUID,
+        canvas_id: UUID,
+        version: int,
+    ) -> dict[str, Any]:
+        canvas = await self.get_canvas(session, tenant_id, canvas_id)
+
+        if canvas.version == version:
+            return {
+                "id": str(canvas.id),
+                "tenant_id": str(canvas.tenant_id),
+                "name": canvas.name,
+                "width": canvas.width,
+                "height": canvas.height,
+                "elements": canvas.elements,
+                "version": canvas.version,
+                "created_at": canvas.created_at.isoformat(),
+                "updated_at": canvas.updated_at.isoformat(),
+            }
+
+        version_doc = await get_archived_version(canvas_id, version)
+        if not version_doc:
+            raise NotFoundError(self._RESOURCE_VERSION, f"{canvas_id} v{version}")
+
+        return version_doc
+
+    async def _ensure_tenant_exists(self, session: AsyncSession, tenant_id: UUID) -> None:
+        query = select(Tenant.id).where(Tenant.id == tenant_id)
+        result = await session.execute(query)
+        if not result.scalar_one_or_none():
+            resource = "Tenant"
+            raise NotFoundError(resource, str(tenant_id))
+
+
+floor_canvas_service = FloorCanvasService()
diff --git a/app/api/services/payment_service.py b/app/api/services/payment_service.py
new file mode 100644
index 0000000..a2ba673
--- /dev/null
+++ b/app/api/services/payment_service.py
@@ -0,0 +1,38 @@
+import base64
+import hashlib
+import json
+
+from core.foundation.infra.config import settings
+
+
+class P24Service:
+    def __init__(self) -> None:
+        self._merchant_id = settings.PRZELEWY24_MERCHANT_ID
+        self._pos_id = settings.PRZELEWY24_POS_ID
+        self._crc = settings.PRZELEWY24_CRC
+        self._api_key = settings.PRZELEWY24_API_KEY
+        self._api_url = settings.PRZELEWY24_API_URL
+
+    _PRZELEWY24_SERVICE_NAME = "Przelewy24"
+
+    @staticmethod
+    def _przelewy24_sign(
+        session_id: str,
+        merchant_id: int,
+        amount: int,
+        currency: str,
+        crc: str,
+    ) -> str:
+        sign_data = {
+            "sessionId": session_id,
+            "merchantId": merchant_id,
+            "amount": amount,
+            "currency": currency,
+            "crc": crc,
+        }
+        payload = json.dumps(sign_data, separators=(",", ":"), ensure_ascii=False)
+        return hashlib.sha384(payload.encode("utf-8")).hexdigest()
+
+    def _przelewy24_basic_auth(self) -> str:
+        raw = f"{self._merchant_id}:{self._api_key}"
+        return f"Basic {base64.b64encode(raw.encode('utf-8')).decode('utf-8')}"
diff --git a/app/api/services/tenant_service.py b/app/api/services/tenant_service.py
new file mode 100644
index 0000000..66a177d
--- /dev/null
+++ b/app/api/services/tenant_service.py
@@ -0,0 +1,85 @@
+# core/services/tenant_service.py
+
+from uuid import UUID
+
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+from sqlalchemy.orm import selectinload
+
+from core.dto.v1.tenants import CreateTenantDTO, UpdateTenantDTO
+from core.exceptions import NotFoundError
+from core.models import Tenant
+
+
+class TenantService:
+    _RESOURCE = "Tenant"
+
+    async def list_tenants(self, session: AsyncSession) -> list[Tenant]:
+        query = (
+            select(Tenant)
+            .options(selectinload(Tenant.floor_canvases))
+            .order_by(Tenant.created_at.desc())
+        )
+        result = await session.execute(query)
+        return list(result.scalars().all())
+
+    async def get_tenant(self, session: AsyncSession, tenant_id: UUID) -> Tenant:
+        query = (
+            select(Tenant)
+            .options(selectinload(Tenant.floor_canvases))
+            .where(Tenant.id == tenant_id)
+        )
+        result = await session.execute(query)
+        tenant = result.scalar_one_or_none()
+
+        if not tenant:
+            raise NotFoundError(self._RESOURCE, str(tenant_id))
+
+        return tenant
+
+    async def create_tenant(self, session: AsyncSession, data: CreateTenantDTO) -> Tenant:
+        tenant = Tenant(
+            name=data.name,
+            slug=data.slug,
+            status=data.status,
+        )
+        session.add(tenant)
+        await session.commit()
+        await session.refresh(tenant, attribute_names=["floor_canvases"])
+        return tenant
+
+    async def update_tenant(
+        self, session: AsyncSession, tenant_id: UUID, data: UpdateTenantDTO
+    ) -> Tenant:
+        tenant = await self.get_tenant(session, tenant_id)
+
+        if data.name is not None:
+            tenant.name = data.name
+        if data.slug is not None:
+            tenant.slug = data.slug
+        if data.status is not None:
+            tenant.status = data.status
+        if data.active_layout_version_id is not None:
+            tenant.active_layout_version_id = data.active_layout_version_id
+
+        await session.commit()
+        await session.refresh(tenant, attribute_names=["floor_canvases"])
+        return tenant
+
+    async def delete_tenant(self, session: AsyncSession, tenant_id: UUID) -> None:
+        tenant = await self._get_tenant_without_relations(session, tenant_id)
+        await session.delete(tenant)
+        await session.commit()
+
+    async def _get_tenant_without_relations(self, session: AsyncSession, tenant_id: UUID) -> Tenant:
+        query = select(Tenant).where(Tenant.id == tenant_id)
+        result = await session.execute(query)
+        tenant = result.scalar_one_or_none()
+
+        if not tenant:
+            raise NotFoundError(self._RESOURCE, str(tenant_id))
+
+        return tenant
+
+
+tenant_service = TenantService()
diff --git a/app/api/services/user_service.py b/app/api/services/user_service.py
new file mode 100644
index 0000000..7f74eaa
--- /dev/null
+++ b/app/api/services/user_service.py
@@ -0,0 +1,68 @@
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from core.exceptions import ConflictError
+from core.foundation.security import SecurityService
+from core.models.enums import AccountType, TenantStatus
+from core.models.tenant import Tenant
+from core.models.tenant_role import TenantRole
+from core.models.user import User
+from core.models.user_tenant import UserTenant
+
+
+class UserService:
+    def __init__(self, security: SecurityService) -> None:
+        self._resend_cooldown_seconds = 300
+        self.security = security
+
+    async def create_user_with_tenant(
+        self,
+        session: AsyncSession,
+        email: str,
+        password: str,
+        restaurant_name: str,
+    ) -> tuple[User, Tenant, TenantRole]:
+        slug = "".join(restaurant_name.split()).lower()
+
+        existing_user = await session.scalar(select(User).where(User.email == email))
+        if existing_user:
+            msg = "Email already registered"
+            raise ConflictError(msg)
+
+        existing_tenant = await session.scalar(select(Tenant).where(Tenant.slug == slug))
+        if existing_tenant:
+            msg = "Restaurant slug already exists"
+            raise ConflictError(msg)
+
+        user = User(
+            email=email,
+            password_hash=self.security.hash_password(password),
+            is_active=False,
+        )
+        tenant = Tenant(
+            name=restaurant_name,
+            slug=slug,
+            status=TenantStatus.INACTIVE,
+        )
+
+        session.add_all([user, tenant])
+        await session.flush()
+        user.tenant_id = tenant.id
+        tenant.owner_id = user.id
+        await session.flush()
+        await session.refresh(user)
+        await session.refresh(tenant)
+
+        user_tenant = UserTenant(
+            user_id=user.id,
+            tenant_id=tenant.id,
+            role=AccountType.OWNER,
+        )
+        tenant_role = TenantRole(
+            account_id=user.id,
+            tenant_id=tenant.id,
+        )
+        session.add_all([user_tenant, tenant_role])
+        await session.flush()
+
+        return user, tenant, tenant_role
diff --git a/app/api/tests/unit/api/test_dto_users.py b/app/api/tests/unit/api/test_dto_users.py
index 73d64c3..6d0f853 100644
--- a/app/api/tests/unit/api/test_dto_users.py
+++ b/app/api/tests/unit/api/test_dto_users.py
@@ -4,8 +4,8 @@ from uuid import uuid4
 from pydantic import ValidationError
 import pytest
 
-from api.v1.dto.common import AccountType
-from api.v1.dto.users import (
+from core.dto.v1.common import AccountType
+from core.dto.v1.users import (
     CreateUserDTO,
     CreateUserTenantDTO,
     UpdateUserDTO,
diff --git a/app/api/tests/unit/core/test_create_payment.py b/app/api/tests/unit/core/test_create_payment.py
index abc554e..b07c684 100644
--- a/app/api/tests/unit/core/test_create_payment.py
+++ b/app/api/tests/unit/core/test_create_payment.py
@@ -1,23 +1,19 @@
-from unittest.mock import AsyncMock, patch
+from unittest.mock import AsyncMock, Mock, patch
 
 import pytest
 
 from core.exceptions import ExternalAPIError, ServiceUnavailableError
-from core.foundation.http.schemas import CreatedResponse
+from core.foundation.http.responses import CreatedResponse
 from core.models import CreatePaymentRequest
-from routes.v1.payments.create_payment import (
-    _przelewy24_sign as calculate_przelewy24_sign,
-)
-from routes.v1.payments.create_payment import (
-    create_payment,
-)
+from routes.v1.payments.create_payment import create_payment
+from services.payment_service import P24Service
 
 
 class TestCalculatePrzelewy24Sign:
     EXPECTED_SIGN_LENGTH = 96
 
     def test_returns_96_char_hex_string(self) -> None:
-        result = calculate_przelewy24_sign(
+        result = P24Service._przelewy24_sign(
             session_id="s1",
             merchant_id=1,
             amount=100,
@@ -28,18 +24,18 @@ class TestCalculatePrzelewy24Sign:
         assert all(c in "0123456789abcdef" for c in result)
 
     def test_deterministic_for_same_inputs(self) -> None:
-        a = calculate_przelewy24_sign("s", 1, 100, "PLN", "x")
-        b = calculate_przelewy24_sign("s", 1, 100, "PLN", "x")
+        a = P24Service._przelewy24_sign("s", 1, 100, "PLN", "x")
+        b = P24Service._przelewy24_sign("s", 1, 100, "PLN", "x")
         assert a == b
 
     def test_different_inputs_different_sign(self) -> None:
-        a = calculate_przelewy24_sign("s1", 1, 100, "PLN", "crc")
-        b = calculate_przelewy24_sign("s2", 1, 100, "PLN", "crc")
+        a = P24Service._przelewy24_sign("s1", 1, 100, "PLN", "crc")
+        b = P24Service._przelewy24_sign("s2", 1, 100, "PLN", "crc")
         assert a != b
 
     def test_utf8_currency_in_sign(self) -> None:
-        result_pln = calculate_przelewy24_sign("s", 1, 100, "PLN", "c")
-        result_eur = calculate_przelewy24_sign("s", 1, 100, "EUR", "c")
+        result_pln = P24Service._przelewy24_sign("s", 1, 100, "PLN", "c")
+        result_eur = P24Service._przelewy24_sign("s", 1, 100, "EUR", "c")
         assert result_pln != result_eur
 
 
@@ -70,27 +66,27 @@ async def test_create_payment_success(
     create_payment_request: CreatePaymentRequest,
     przelewy24_success_response: dict,
 ) -> None:
-    with (
-        patch("routes.v1.payments.create_payment.settings") as mock_settings,
-        patch(
-            "routes.v1.payments.create_payment.external_post_json",
-            new_callable=AsyncMock,
-        ) as mock_post,
-    ):
-        mock_settings.PRZELEWY24_MERCHANT_ID = 12345
-        mock_settings.PRZELEWY24_POS_ID = 12345
-        mock_settings.PRZELEWY24_CRC = "test-crc"
-        mock_settings.PRZELEWY24_API_KEY = "test-api-key"
+    with patch("routes.v1.payments.create_payment.settings") as mock_settings:
         mock_settings.PRZELEWY24_API_URL = "https://sandbox.przelewy24.pl/api/v1"
-        mock_post.return_value = przelewy24_success_response
 
-        result = await create_payment(create_payment_request)
+        service = Mock()
+        service._merchant_id = 12345
+        service._pos_id = 12345
+        service._crc = "test-crc"
+        service._PRZELEWY24_SERVICE_NAME = "Przelewy24"
+        service._przelewy24_sign.return_value = "a" * 96
+        service._przelewy24_basic_auth.return_value = "Basic test-auth"
+
+        external_client = Mock()
+        external_client.external_post_json = AsyncMock(return_value=przelewy24_success_response)
+
+        result = await create_payment(create_payment_request, service, external_client)
 
     assert isinstance(result, CreatedResponse)
     assert result.message == "Payment transaction created successfully"
     assert result.data == przelewy24_success_response
-    mock_post.assert_called_once()
-    args, kwargs = mock_post.call_args
+    external_client.external_post_json.assert_called_once()
+    args, kwargs = external_client.external_post_json.call_args
     assert "transaction/register" in str(args[0])
     assert kwargs.get("headers", {}).get("Authorization", "").startswith("Basic ")
 
@@ -100,25 +96,27 @@ async def test_create_payment_http_status_error(
     create_payment_request: CreatePaymentRequest,
 ) -> None:
     status_code = 400
-    with (
-        patch("routes.v1.payments.create_payment.settings") as mock_settings,
-        patch(
-            "routes.v1.payments.create_payment.external_post_json",
-            new_callable=AsyncMock,
-        ) as mock_post,
-    ):
-        mock_settings.PRZELEWY24_MERCHANT_ID = 12345
-        mock_settings.PRZELEWY24_POS_ID = 12345
-        mock_settings.PRZELEWY24_CRC = "crc"
-        mock_settings.PRZELEWY24_API_KEY = "key"
+    with patch("routes.v1.payments.create_payment.settings") as mock_settings:
         mock_settings.PRZELEWY24_API_URL = "https://sandbox.przelewy24.pl/api/v1"
-        mock_post.side_effect = ExternalAPIError(
-            status_code=400,
-            message="Przelewy24 error: Invalid merchant configuration",
+
+        service = Mock()
+        service._merchant_id = 12345
+        service._pos_id = 12345
+        service._crc = "crc"
+        service._PRZELEWY24_SERVICE_NAME = "Przelewy24"
+        service._przelewy24_sign.return_value = "a" * 96
+        service._przelewy24_basic_auth.return_value = "Basic test-auth"
+
+        external_client = Mock()
+        external_client.external_post_json = AsyncMock(
+            side_effect=ExternalAPIError(
+                status_code=400,
+                message="Przelewy24 error: Invalid merchant configuration",
+            )
         )
 
         with pytest.raises(ExternalAPIError) as exc_info:
-            await create_payment(create_payment_request)
+            await create_payment(create_payment_request, service, external_client)
 
         assert exc_info.value.status_code == status_code
         assert "Przelewy24" in exc_info.value.detail
@@ -130,24 +128,26 @@ async def test_create_payment_request_error(
     create_payment_request: CreatePaymentRequest,
 ) -> None:
     status_code = 503
-    with (
-        patch("routes.v1.payments.create_payment.settings") as mock_settings,
-        patch(
-            "routes.v1.payments.create_payment.external_post_json",
-            new_callable=AsyncMock,
-        ) as mock_post,
-    ):
-        mock_settings.PRZELEWY24_MERCHANT_ID = 12345
-        mock_settings.PRZELEWY24_POS_ID = 12345
-        mock_settings.PRZELEWY24_CRC = "crc"
-        mock_settings.PRZELEWY24_API_KEY = "key"
+    with patch("routes.v1.payments.create_payment.settings") as mock_settings:
         mock_settings.PRZELEWY24_API_URL = "https://sandbox.przelewy24.pl/api/v1"
-        mock_post.side_effect = ServiceUnavailableError(
-            message="Failed to connect to Przelewy24: Connection refused",
+
+        service = Mock()
+        service._merchant_id = 12345
+        service._pos_id = 12345
+        service._crc = "crc"
+        service._PRZELEWY24_SERVICE_NAME = "Przelewy24"
+        service._przelewy24_sign.return_value = "a" * 96
+        service._przelewy24_basic_auth.return_value = "Basic test-auth"
+
+        external_client = Mock()
+        external_client.external_post_json = AsyncMock(
+            side_effect=ServiceUnavailableError(
+                message="Failed to connect to Przelewy24: Connection refused",
+            )
         )
 
         with pytest.raises(ServiceUnavailableError) as exc_info:
-            await create_payment(create_payment_request)
+            await create_payment(create_payment_request, service, external_client)
 
         assert exc_info.value.status_code == status_code
         assert "Przelewy24" in exc_info.value.detail
diff --git a/app/api/tests/unit/core/test_dependencies.py b/app/api/tests/unit/core/test_dependencies.py
index aa1668d..58f258e 100644
--- a/app/api/tests/unit/core/test_dependencies.py
+++ b/app/api/tests/unit/core/test_dependencies.py
@@ -33,3 +33,67 @@ async def test_get_postgres_connection_pool(monkeypatch: pytest.MonkeyPatch) ->
     pool = await dependencies.get_postgres_connection_pool()
 
     assert isinstance(pool, DummyPool)
+
+
+def test_get_security_service_returns_singleton() -> None:
+    service = dependencies.get_security_service()
+    assert service is dependencies.security_service
+
+
+def test_get_auth_service_uses_passed_security(monkeypatch: pytest.MonkeyPatch) -> None:
+    class DummyAuthService:
+        def __init__(self, security: object) -> None:
+            self.security = security
+
+    monkeypatch.setattr(dependencies, "AuthService", DummyAuthService)
+    security = object()
+
+    service = dependencies.get_auth_service(security=security)
+
+    assert isinstance(service, DummyAuthService)
+    assert service.security is security
+
+
+def test_get_email_service_returns_instance(monkeypatch: pytest.MonkeyPatch) -> None:
+    class DummyEmailService:
+        pass
+
+    monkeypatch.setattr(dependencies, "EmailService", DummyEmailService)
+    service = dependencies.get_email_service()
+    assert isinstance(service, DummyEmailService)
+
+
+def test_get_tenant_service_returns_instance(monkeypatch: pytest.MonkeyPatch) -> None:
+    class DummyTenantService:
+        pass
+
+    monkeypatch.setattr(dependencies, "TenantService", DummyTenantService)
+    service = dependencies.get_tenant_service()
+    assert isinstance(service, DummyTenantService)
+
+
+def test_get_floor_canvas_service_returns_instance(monkeypatch: pytest.MonkeyPatch) -> None:
+    class DummyFloorCanvasService:
+        pass
+
+    monkeypatch.setattr(dependencies, "FloorCanvasService", DummyFloorCanvasService)
+    service = dependencies.get_floor_canvas_service()
+    assert isinstance(service, DummyFloorCanvasService)
+
+
+def test_get_p24_service_returns_instance(monkeypatch: pytest.MonkeyPatch) -> None:
+    class DummyP24Service:
+        pass
+
+    monkeypatch.setattr(dependencies, "P24Service", DummyP24Service)
+    service = dependencies.get_p24_service()
+    assert isinstance(service, DummyP24Service)
+
+
+def test_get_external_client_returns_instance(monkeypatch: pytest.MonkeyPatch) -> None:
+    class DummyExternalClient:
+        pass
+
+    monkeypatch.setattr(dependencies, "ExternalClient", DummyExternalClient)
+    service = dependencies.get_external_client()
+    assert isinstance(service, DummyExternalClient)
diff --git a/app/api/tests/unit/core/test_external_client.py b/app/api/tests/unit/core/test_external_client.py
index 6247b32..ad09768 100644
--- a/app/api/tests/unit/core/test_external_client.py
+++ b/app/api/tests/unit/core/test_external_client.py
@@ -4,7 +4,7 @@ import httpx
 import pytest
 
 from core.exceptions import ExternalAPIError, ServiceUnavailableError
-from core.foundation.http.external_client import external_post_json
+from services.external_client_service import ExternalClient
 
 
 @pytest.mark.asyncio
@@ -13,12 +13,12 @@ async def test_external_post_json_success_returns_json() -> None:
     mock_response.raise_for_status = MagicMock()
     mock_response.json.return_value = {"token": "abc123", "status": "ok"}
 
-    with patch("core.foundation.http.external_client.httpx.AsyncClient") as mock_client_cls:
+    with patch("services.external_client_service.httpx.AsyncClient") as mock_client_cls:
         mock_post = AsyncMock(return_value=mock_response)
         mock_client_cls.return_value.__aenter__.return_value.post = mock_post
         mock_client_cls.return_value.__aexit__ = AsyncMock(return_value=None)
 
-        result = await external_post_json(
+        result = await ExternalClient().external_post_json(
             "https://api.example.com/register",
             json={"key": "value"},
             headers={"Authorization": "Bearer x"},
@@ -45,7 +45,7 @@ async def test_external_post_json_http_status_error_raises_external_api_error()
     mock_response.json.return_value = {"error": {"message": "Invalid request"}}
     mock_response.text = "Bad Request"
 
-    with patch("core.foundation.http.external_client.httpx.AsyncClient") as mock_client_cls:
+    with patch("services.external_client_service.httpx.AsyncClient") as mock_client_cls:
         mock_post = AsyncMock(
             side_effect=httpx.HTTPStatusError(
                 "Bad Request",
@@ -57,7 +57,7 @@ async def test_external_post_json_http_status_error_raises_external_api_error()
         mock_client_cls.return_value.__aexit__ = AsyncMock(return_value=None)
 
         with pytest.raises(ExternalAPIError) as exc_info:
-            await external_post_json(
+            await ExternalClient().external_post_json(
                 "https://api.example.com/endpoint",
                 json={},
                 service_name="Example API",
@@ -71,13 +71,13 @@ async def test_external_post_json_http_status_error_raises_external_api_error()
 @pytest.mark.asyncio
 async def test_external_post_json_request_error_raises_service_unavailable() -> None:
     status_code = 503
-    with patch("core.foundation.http.external_client.httpx.AsyncClient") as mock_client_cls:
+    with patch("services.external_client_service.httpx.AsyncClient") as mock_client_cls:
         mock_post = AsyncMock(side_effect=httpx.ConnectError("Connection refused"))
         mock_client_cls.return_value.__aenter__.return_value.post = mock_post
         mock_client_cls.return_value.__aexit__ = AsyncMock(return_value=None)
 
         with pytest.raises(ServiceUnavailableError) as exc_info:
-            await external_post_json(
+            await ExternalClient().external_post_json(
                 "https://api.example.com/endpoint",
                 json={},
                 service_name="Example API",
@@ -95,7 +95,7 @@ async def test_external_post_json_extract_error_from_body_errors_key() -> None:
     mock_response.json.return_value = {"errors": "Validation failed"}
     mock_response.text = "Unprocessable Entity"
 
-    with patch("core.foundation.http.external_client.httpx.AsyncClient") as mock_client_cls:
+    with patch("services.external_client_service.httpx.AsyncClient") as mock_client_cls:
         mock_post = AsyncMock(
             side_effect=httpx.HTTPStatusError(
                 "Unprocessable",
@@ -107,7 +107,7 @@ async def test_external_post_json_extract_error_from_body_errors_key() -> None:
         mock_client_cls.return_value.__aexit__ = AsyncMock(return_value=None)
 
         with pytest.raises(ExternalAPIError) as exc_info:
-            await external_post_json("https://api.example.com", json={})
+            await ExternalClient().external_post_json("https://api.example.com", json={})
 
         assert "Validation failed" in exc_info.value.detail
 
@@ -119,7 +119,7 @@ async def test_external_post_json_extract_error_fallback_to_response_text() -> N
     mock_response.json.side_effect = ValueError("not json")
     mock_response.text = "Internal Server Error"
 
-    with patch("core.foundation.http.external_client.httpx.AsyncClient") as mock_client_cls:
+    with patch("services.external_client_service.httpx.AsyncClient") as mock_client_cls:
         mock_post = AsyncMock(
             side_effect=httpx.HTTPStatusError(
                 "Server Error",
@@ -131,7 +131,7 @@ async def test_external_post_json_extract_error_fallback_to_response_text() -> N
         mock_client_cls.return_value.__aexit__ = AsyncMock(return_value=None)
 
         with pytest.raises(ExternalAPIError) as exc_info:
-            await external_post_json("https://api.example.com", json={})
+            await ExternalClient().external_post_json("https://api.example.com", json={})
 
         assert exc_info.value.status_code == mock_response.status_code
         assert "Internal Server Error" in exc_info.value.detail
@@ -145,7 +145,7 @@ async def test_external_post_json_extract_error_fallback_inside_try_block() -> N
     mock_response.json.return_value = ["unexpected", "format"]
     mock_response.text = "I'm a teapot"
 
-    with patch("core.foundation.http.external_client.httpx.AsyncClient") as mock_client_cls:
+    with patch("services.external_client_service.httpx.AsyncClient") as mock_client_cls:
         mock_post = AsyncMock(
             side_effect=httpx.HTTPStatusError(
                 "Teapot Error",
@@ -157,7 +157,7 @@ async def test_external_post_json_extract_error_fallback_inside_try_block() -> N
         mock_client_cls.return_value.__aexit__ = AsyncMock(return_value=None)
 
         with pytest.raises(ExternalAPIError) as exc_info:
-            await external_post_json(
+            await ExternalClient().external_post_json(
                 "https://api.example.com/endpoint",
                 json={},
                 service_name="Example API",
diff --git a/app/api/tests/unit/core/test_middleware.py b/app/api/tests/unit/core/test_middleware.py
index ba7231b..a00fa1c 100644
--- a/app/api/tests/unit/core/test_middleware.py
+++ b/app/api/tests/unit/core/test_middleware.py
@@ -1,3 +1,5 @@
+from unittest.mock import patch
+
 from fastapi import FastAPI, Request, Response
 from fastapi.middleware.cors import CORSMiddleware
 import pytest
@@ -49,9 +51,51 @@ async def test_unauthorized_middleware_passes_other_status() -> None:
         return Response(status_code=200)
 
     middleware = UnauthorizedMiddleware(call_next)
-    scope = {"type": "http", "method": "GET", "path": "/", "headers": []}
+    scope = {
+        "type": "http",
+        "method": "GET",
+        "path": "/",
+        "headers": [(b"authorization", b"Bearer valid-token")],
+    }
     request = Request(scope)
 
-    response = await middleware.dispatch(request, call_next)
+    with patch.object(middleware._security, "decode_access_token", return_value={"sub": "user-1"}):
+        response = await middleware.dispatch(request, call_next)
 
     assert response.status_code == 200  # noqa: PLR2004
+
+
+@pytest.mark.asyncio
+async def test_unauthorized_middleware_allows_public_routes() -> None:
+    async def call_next(_: Request) -> Response:
+        return Response(status_code=204)
+
+    middleware = UnauthorizedMiddleware(call_next)
+    scope = {"type": "http", "method": "GET", "path": "/docs", "headers": []}
+    request = Request(scope)
+
+    response = await middleware.dispatch(request, call_next)
+
+    assert response.status_code == 204  # noqa: PLR2004
+
+
+@pytest.mark.asyncio
+async def test_unauthorized_middleware_returns_401_on_invalid_token() -> None:
+    async def call_next(_: Request) -> Response:
+        return Response(status_code=200)
+
+    middleware = UnauthorizedMiddleware(call_next)
+    scope = {
+        "type": "http",
+        "method": "GET",
+        "path": "/",
+        "headers": [(b"authorization", b"Bearer invalid-token")],
+    }
+    request = Request(scope)
+
+    with patch.object(
+        middleware._security, "decode_access_token", side_effect=Exception("bad token")
+    ):
+        response = await middleware.dispatch(request, call_next)
+
+    assert response.status_code == 401  # noqa: PLR2004
diff --git a/app/api/tests/unit/core/test_responses.py b/app/api/tests/unit/core/test_responses.py
deleted file mode 100644
index 385c4c1..0000000
--- a/app/api/tests/unit/core/test_responses.py
+++ /dev/null
@@ -1,134 +0,0 @@
-from fastapi import status
-
-from core.foundation.http.responses import (
-    created_response,
-    deleted_response,
-    error_response,
-    paginated_response,
-    success_response,
-    updated_response,
-)
-from core.foundation.http.schemas import PaginatedResponse as PaginatedResponseSchema
-
-
-class TestSuccessResponse:
-    def test_success_response_with_data(self) -> None:
-        data = {"id": 1, "name": "Test"}
-        response = success_response(data)
-
-        assert response.status_code == status.HTTP_200_OK
-        content = response.body.decode()
-        assert "data" in content
-        assert "id" in content
-
-    def test_success_response_with_message(self) -> None:
-        data = {"id": 1}
-        message = "Operation successful"
-        response = success_response(data, message=message)
-
-        assert response.status_code == status.HTTP_200_OK
-        content = response.body.decode()
-        assert message in content
-
-    def test_success_response_with_custom_status_code(self) -> None:
-        data = {"id": 1}
-        response = success_response(data, status_code=status.HTTP_202_ACCEPTED)
-
-        assert response.status_code == status.HTTP_202_ACCEPTED
-
-
-class TestCreatedResponse:
-    def test_created_response_default_message(self) -> None:
-        data = {"id": 1, "name": "Test"}
-        response = created_response(data)
-
-        assert response.status_code == status.HTTP_201_CREATED
-        content = response.body.decode()
-        assert "Resource created successfully" in content
-
-    def test_created_response_custom_message(self) -> None:
-        data = {"id": 1}
-        message = "User created"
-        response = created_response(data, message=message)
-
-        assert response.status_code == status.HTTP_201_CREATED
-        content = response.body.decode()
-        assert message in content
-
-
-class TestUpdatedResponse:
-    def test_updated_response_default_message(self) -> None:
-        data = {"id": 1, "name": "Updated"}
-        response = updated_response(data)
-
-        assert response.status_code == status.HTTP_200_OK
-        content = response.body.decode()
-        assert "Resource updated successfully" in content
-
-    def test_updated_response_custom_message(self) -> None:
-        data = {"id": 1}
-        message = "User updated"
-        response = updated_response(data, message=message)
-
-        assert response.status_code == status.HTTP_200_OK
-        content = response.body.decode()
-        assert message in content
-
-
-class TestDeletedResponse:
-    def test_deleted_response_default_message(self) -> None:
-        response = deleted_response()
-
-        assert response.status_code == status.HTTP_200_OK
-        content = response.body.decode()
-        assert "Resource deleted successfully" in content
-
-    def test_deleted_response_custom_message(self) -> None:
-        message = "User deleted"
-        response = deleted_response(message=message)
-
-        assert response.status_code == status.HTTP_200_OK
-        content = response.body.decode()
-        assert message in content
-
-
-class TestPaginatedResponse:
-    def test_paginated_response(self) -> None:
-        paginated_data = PaginatedResponseSchema(
-            items=[{"id": 1}, {"id": 2}],
-            total=2,
-            page=1,
-            page_size=10,
-            total_pages=1,
-        )
-        response = paginated_response(paginated_data)
-
-        assert response.status_code == status.HTTP_200_OK
-        content = response.body.decode()
-        assert "items" in content
-        assert "total" in content
-
-
-class TestErrorResponse:
-    def test_error_response_default_status(self) -> None:
-        response = error_response("TEST_ERROR", "Test error message")
-
-        assert response.status_code == status.HTTP_400_BAD_REQUEST
-        content = response.body.decode()
-        assert "TEST_ERROR" in content
-        assert "Test error message" in content
-
-    def test_error_response_custom_status(self) -> None:
-        response = error_response(
-            "NOT_FOUND", "Resource not found", status_code=status.HTTP_404_NOT_FOUND
-        )
-
-        assert response.status_code == status.HTTP_404_NOT_FOUND
-
-    def test_error_response_with_details(self) -> None:
-        details = {"field": "email", "reason": "invalid format"}
-        response = error_response("VALIDATION_ERROR", "Validation failed", details=details)
-
-        assert response.status_code == status.HTTP_400_BAD_REQUEST
-        content = response.body.decode()
-        assert "details" in content
diff --git a/app/api/tests/unit/core/test_router.py b/app/api/tests/unit/core/test_router.py
deleted file mode 100644
index 5651b39..0000000
--- a/app/api/tests/unit/core/test_router.py
+++ /dev/null
@@ -1,91 +0,0 @@
-from fastapi import APIRouter, Request, Response
-from fastapi.routing import APIRoute
-
-from core.foundation.http.router import RouterSingleton, TimedRoute, create_router
-
-
-class TestRouterSingleton:
-    def test_singleton_pattern(self) -> None:
-        instance1 = RouterSingleton()
-        instance2 = RouterSingleton()
-
-        assert instance1 is instance2
-
-    def test_router_property_creates_router(self) -> None:
-        singleton = RouterSingleton()
-        router = singleton.router
-
-        assert isinstance(router, APIRouter)
-
-    def test_router_property_returns_same_instance(self) -> None:
-        singleton = RouterSingleton()
-        router1 = singleton.router
-        router2 = singleton.router
-
-        assert router1 is router2
-
-    def test_reset_clears_router(self) -> None:
-        singleton = RouterSingleton()
-        router1 = singleton.router
-        singleton.reset()
-        router2 = singleton.router
-
-        assert router1 is not router2
-
-
-class TestCreateRouter:
-    def test_create_router_with_defaults(self) -> None:
-        router = create_router()
-
-        assert isinstance(router, APIRouter)
-        assert router.prefix == ""
-
-    def test_create_router_with_prefix(self) -> None:
-        router = create_router(prefix="/api/v1")
-
-        assert isinstance(router, APIRouter)
-        assert router.prefix == "/api/v1"
-
-    def test_create_router_with_tags(self) -> None:
-        tags = ["users", "auth"]
-        router = create_router(tags=tags)
-
-        assert isinstance(router, APIRouter)
-        assert router.tags == tags
-
-    def test_create_router_with_dependencies(self) -> None:
-        dependencies = []
-        router = create_router(dependencies=dependencies)
-
-        assert isinstance(router, APIRouter)
-        assert router.dependencies == dependencies
-
-
-class TestTimedRoute:
-    def test_timed_route_is_apiroute_subclass(self) -> None:
-        assert issubclass(TimedRoute, APIRoute)
-
-    async def test_timed_route_adds_header(self) -> None:
-        async def endpoint() -> Response:
-            return Response(content="ok")
-
-        route = TimedRoute(
-            path="/",
-            endpoint=endpoint,
-            methods=["GET"],
-        )
-
-        handler = route.get_route_handler()
-
-        scope = {
-            "type": "http",
-            "method": "GET",
-            "path": "/",
-            "headers": [],
-            "query_string": b"",
-        }
-        request = Request(scope)
-
-        response = await handler(request)
-
-        assert "X-Process-Time" in response.headers
diff --git a/app/api/tests/unit/core/test_schemas.py b/app/api/tests/unit/core/test_schemas.py
index 746e92a..3971b72 100644
--- a/app/api/tests/unit/core/test_schemas.py
+++ b/app/api/tests/unit/core/test_schemas.py
@@ -1,4 +1,4 @@
-from core.foundation.http.schemas import PaginatedResponse
+from core.foundation.http.responses import PaginatedResponse
 
 
 class TestPaginatedResponseCreate:
diff --git a/app/api/tests/unit/core/test_security.py b/app/api/tests/unit/core/test_security.py
index a6c4d92..a81da01 100644
--- a/app/api/tests/unit/core/test_security.py
+++ b/app/api/tests/unit/core/test_security.py
@@ -1,42 +1,45 @@
 from datetime import timedelta
+from unittest.mock import Mock, patch
 
+from fastapi import Request
+import pytest
+
+from core.exceptions import UnauthorizedError
 from core.foundation.security import (
-    create_access_token,
-    decode_access_token,
-    hash_password,
-    verify_password,
+    SecurityService,
+    get_current_user,
 )
 
 
 class TestCreateAccessToken:
     def test_create_access_token_with_default_expiry(self) -> None:
+        service = SecurityService()
         data = {"sub": "test@example.com"}
-        token = create_access_token(data)
+        token = service.create_access_token(data)
 
         assert isinstance(token, str)
         assert len(token) > 0
 
-        decoded = decode_access_token(token)
-        assert decoded is not None
+        decoded = service.decode_access_token(token)
         assert decoded["sub"] == "test@example.com"
         assert "exp" in decoded
 
     def test_create_access_token_with_custom_expiry(self) -> None:
+        service = SecurityService()
         data = {"sub": "test@example.com"}
         expires_delta = timedelta(minutes=30)
-        token = create_access_token(data, expires_delta=expires_delta)
+        token = service.create_access_token(data, expires_delta=expires_delta)
 
         assert isinstance(token, str)
-        decoded = decode_access_token(token)
-        assert decoded is not None
+        decoded = service.decode_access_token(token)
         assert decoded["sub"] == "test@example.com"
 
     def test_create_access_token_preserves_data(self) -> None:
+        service = SecurityService()
         data = {"sub": "user@example.com", "role": "admin", "tenant_id": "123"}
-        token = create_access_token(data)
+        token = service.create_access_token(data)
 
-        decoded = decode_access_token(token)
-        assert decoded is not None
+        decoded = service.decode_access_token(token)
         assert decoded["sub"] == "user@example.com"
         assert decoded["role"] == "admin"
         assert decoded["tenant_id"] == "123"
@@ -44,47 +47,59 @@ class TestCreateAccessToken:
 
 class TestDecodeAccessToken:
     def test_decode_valid_token(self) -> None:
+        service = SecurityService()
         data = {"sub": "test@example.com"}
-        token = create_access_token(data)
+        token = service.create_access_token(data)
 
-        decoded = decode_access_token(token)
-        assert decoded is not None
+        decoded = service.decode_access_token(token)
         assert decoded["sub"] == "test@example.com"
 
     def test_decode_invalid_token(self) -> None:
+        service = SecurityService()
         invalid_token = "invalid.token.here"
-        decoded = decode_access_token(invalid_token)
-        assert decoded is None
+        with pytest.raises(UnauthorizedError):
+            service.decode_access_token(invalid_token)
 
     def test_decode_empty_token(self) -> None:
-        decoded = decode_access_token("")
-        assert decoded is None
+        service = SecurityService()
+        with pytest.raises(UnauthorizedError):
+            service.decode_access_token("")
 
     def test_decode_malformed_token(self) -> None:
+        service = SecurityService()
         malformed_token = "not.a.valid.jwt.token"
-        decoded = decode_access_token(malformed_token)
-        assert decoded is None
+        with pytest.raises(UnauthorizedError):
+            service.decode_access_token(malformed_token)
+
+    def test_decode_access_token_handles_unexpected_exception(self) -> None:
+        service = SecurityService()
+        with patch("core.foundation.security.jwt.decode", side_effect=RuntimeError("boom")):
+            with pytest.raises(UnauthorizedError):
+                service.decode_access_token("any-token")
 
 
 class TestHashPassword:
     def test_hash_password_returns_different_hash(self) -> None:
+        service = SecurityService()
         password = "test_password_123"
-        hashed = hash_password(password)
+        hashed = service.hash_password(password)
 
         assert hashed != password
         assert len(hashed) > 0
         assert hashed.startswith("$2b$")
 
     def test_hash_password_same_password_different_hashes(self) -> None:
+        service = SecurityService()
         password = "test_password_123"
-        hashed1 = hash_password(password)
-        hashed2 = hash_password(password)
+        hashed1 = service.hash_password(password)
+        hashed2 = service.hash_password(password)
 
         assert hashed1 != hashed2
 
     def test_hash_password_empty_string(self) -> None:
+        service = SecurityService()
         password = ""
-        hashed = hash_password(password)
+        hashed = service.hash_password(password)
 
         assert len(hashed) > 0
         assert hashed.startswith("$2b$")
@@ -92,28 +107,60 @@ class TestHashPassword:
 
 class TestVerifyPassword:
     def test_verify_password_correct(self) -> None:
+        service = SecurityService()
         password = "test_password_123"
-        hashed = hash_password(password)
+        hashed = service.hash_password(password)
 
-        assert verify_password(password, hashed) is True
+        assert service.verify_password(password, hashed) is True
 
     def test_verify_password_incorrect(self) -> None:
+        service = SecurityService()
         password = "test_password_123"
-        hashed = hash_password(password)
+        hashed = service.hash_password(password)
 
-        assert verify_password("wrong_password", hashed) is False
+        assert service.verify_password("wrong_password", hashed) is False
 
     def test_verify_password_empty_password(self) -> None:
+        service = SecurityService()
         password = ""
-        hashed = hash_password(password)
+        hashed = service.hash_password(password)
 
-        assert verify_password("", hashed) is True
-        assert verify_password("not_empty", hashed) is False
+        assert service.verify_password("", hashed) is True
+        assert service.verify_password("not_empty", hashed) is False
 
     def test_verify_password_case_sensitive(self) -> None:
+        service = SecurityService()
         password = "TestPassword"
-        hashed = hash_password(password)
-
-        assert verify_password("TestPassword", hashed) is True
-        assert verify_password("testpassword", hashed) is False
-        assert verify_password("TESTPASSWORD", hashed) is False
+        hashed = service.hash_password(password)
+
+        assert service.verify_password("TestPassword", hashed) is True
+        assert service.verify_password("testpassword", hashed) is False
+        assert service.verify_password("TESTPASSWORD", hashed) is False
+
+
+class TestGetCurrentUser:
+    @pytest.mark.asyncio
+    async def test_get_current_user_raises_without_bearer_header(self) -> None:
+        request = Request({"type": "http", "method": "GET", "path": "/", "headers": []})
+        service = Mock()
+
+        with pytest.raises(UnauthorizedError):
+            await get_current_user(service, request)
+
+    @pytest.mark.asyncio
+    async def test_get_current_user_decodes_bearer_token(self) -> None:
+        request = Request(
+            {
+                "type": "http",
+                "method": "GET",
+                "path": "/",
+                "headers": [(b"authorization", b"Bearer token-123")],
+            }
+        )
+        service = Mock()
+        service.decode_access_token.return_value = {"sub": "user@example.com"}
+
+        user = await get_current_user(service, request)
+
+        assert user == {"sub": "user@example.com"}
+        service.decode_access_token.assert_called_once_with(token="token-123")
diff --git a/app/api/tests/unit/modules/auth/test_service.py b/app/api/tests/unit/modules/auth/test_service.py
index 1150d7b..493fd72 100644
--- a/app/api/tests/unit/modules/auth/test_service.py
+++ b/app/api/tests/unit/modules/auth/test_service.py
@@ -10,18 +10,16 @@ from core.exceptions import (
     NotFoundError,
     TooManyRequestsError,
 )
+from core.foundation.security import SecurityService
 from core.models.activation_link import ActivationLink
 from core.models.enums import AccountType, TenantStatus
 from core.models.tenant import Tenant
 from core.models.tenant_role import TenantRole
 from core.models.user import User
 from core.models.user_tenant import UserTenant
-from modules.auth.service import (
-    activate_account,
-    create_activation_link,
-    create_user_with_tenant,
-    resend_activation_link,
-)
+from services.auth_service import AuthService
+
+auth_service = AuthService(security=SecurityService())
 
 PASSWORD_HASH_MIN_LENGTH = 50
 EXPECTED_NEW_LINK_COUNT = 2
@@ -87,7 +85,7 @@ class FakeAsyncSession:
 async def test_create_user_with_tenant_success() -> None:
     session = FakeAsyncSession()
 
-    user, tenant, tenant_role = await create_user_with_tenant(
+    user, tenant = await auth_service.create_user_with_tenant(
         session=session,
         email="owner@example.com",
         password="secure_password",
@@ -113,9 +111,6 @@ async def test_create_user_with_tenant_success() -> None:
     assert user_tenant.tenant_id == tenant.id
     assert user_tenant.role == AccountType.OWNER
     assert len(session.tenant_roles) == 1
-    assert session.tenant_roles[0] is tenant_role
-    assert tenant_role.account_id == user.id
-    assert tenant_role.tenant_id == tenant.id
 
 
 @pytest.mark.asyncio
@@ -132,7 +127,7 @@ async def test_create_user_with_tenant_slug_generation() -> None:
 
     for restaurant_name, expected_slug in test_cases:
         session = FakeAsyncSession()
-        _, tenant, _ = await create_user_with_tenant(
+        _, tenant = await auth_service.create_user_with_tenant(
             session=session,
             email=f"owner{expected_slug}@example.com",
             password="password",
@@ -154,7 +149,7 @@ async def test_create_user_with_tenant_duplicate_email() -> None:
     session.users.append(existing_user)
 
     with pytest.raises(ConflictError) as exc_info:
-        await create_user_with_tenant(
+        await auth_service.create_user_with_tenant(
             session=session,
             email="existing@example.com",
             password="password",
@@ -177,7 +172,7 @@ async def test_create_user_with_tenant_duplicate_slug() -> None:
     session.tenants.append(existing_tenant)
 
     with pytest.raises(ConflictError) as exc_info:
-        await create_user_with_tenant(
+        await auth_service.create_user_with_tenant(
             session=session,
             email="newowner@example.com",
             password="password",
@@ -193,7 +188,7 @@ async def test_create_user_with_tenant_password_is_hashed() -> None:
 
     plain_password = "my_secure_password_123"
 
-    user, _, _ = await create_user_with_tenant(
+    user, _ = await auth_service.create_user_with_tenant(
         session=session,
         email="test@example.com",
         password=plain_password,
@@ -209,7 +204,7 @@ async def test_create_user_with_tenant_password_is_hashed() -> None:
 async def test_create_user_with_tenant_user_tenant_relationship() -> None:
     session = FakeAsyncSession()
 
-    user, tenant, tenant_role = await create_user_with_tenant(
+    user, tenant = await auth_service.create_user_with_tenant(
         session=session,
         email="owner@example.com",
         password="password",
@@ -223,9 +218,6 @@ async def test_create_user_with_tenant_user_tenant_relationship() -> None:
     assert user_tenant.tenant_id == tenant.id
     assert user_tenant.role == AccountType.OWNER
     assert len(session.tenant_roles) == 1
-    assert session.tenant_roles[0] is tenant_role
-    assert tenant_role.account_id == user.id
-    assert tenant_role.tenant_id == tenant.id
     assert tenant.owner_id == user.id
     assert user.tenant_id == tenant.id
 
@@ -248,7 +240,7 @@ async def test_create_activation_link_success() -> None:
     session.users.append(user)
     session.tenants.append(tenant)
 
-    link = await create_activation_link(
+    link = await auth_service.create_activation_link(
         session=session,
         email=user.email,
         user_id=user.id,
@@ -271,7 +263,7 @@ async def test_activate_account_link_not_found() -> None:
     unknown_id = uuid4()
 
     with pytest.raises(NotFoundError) as exc_info:
-        await activate_account(session=session, activation_id=unknown_id)
+        await auth_service.activate_account(session=session, activation_id=unknown_id)
 
     assert str(unknown_id) in exc_info.value.detail
 
@@ -298,7 +290,7 @@ async def test_activate_account_link_expired() -> None:
     session.activation_links.append(link)
 
     with pytest.raises(GoneError) as exc_info:
-        await activate_account(session=session, activation_id=link.id)
+        await auth_service.activate_account(session=session, activation_id=link.id)
 
     assert "expired" in exc_info.value.detail.lower()
 
@@ -323,7 +315,7 @@ async def test_activate_account_tenant_not_found() -> None:
     session.activation_links.append(link)
 
     with pytest.raises(NotFoundError) as exc_info:
-        await activate_account(session=session, activation_id=link.id)
+        await auth_service.activate_account(session=session, activation_id=link.id)
 
     assert "Account" in exc_info.value.detail
 
@@ -350,7 +342,9 @@ async def test_activate_account_already_activated_returns_tenant_true() -> None:
     )
     session.activation_links.append(link)
 
-    result_tenant, already = await activate_account(session=session, activation_id=link.id)
+    result_tenant, already = await auth_service.activate_account(
+        session=session, activation_id=link.id
+    )
 
     assert result_tenant.id == tenant.id
     assert already is True
@@ -377,7 +371,9 @@ async def test_activate_account_success_activates_user_and_tenant() -> None:
     )
     session.activation_links.append(link)
 
-    result_tenant, already = await activate_account(session=session, activation_id=link.id)
+    result_tenant, already = await auth_service.activate_account(
+        session=session, activation_id=link.id
+    )
 
     assert result_tenant.id == tenant.id
     assert already is False
@@ -401,7 +397,7 @@ async def test_activate_account_user_not_found() -> None:
     session.activation_links.append(link)
 
     with pytest.raises(NotFoundError) as exc_info:
-        await activate_account(session=session, activation_id=link.id)
+        await auth_service.activate_account(session=session, activation_id=link.id)
 
     assert "Account" in exc_info.value.detail
 
@@ -412,7 +408,7 @@ async def test_resend_activation_link_not_found() -> None:
     unknown_id = uuid4()
 
     with pytest.raises(NotFoundError) as exc_info:
-        await resend_activation_link(session=session, activation_id=unknown_id)
+        await auth_service.resend_activation_link(session=session, activation_id=unknown_id)
 
     assert str(unknown_id) in exc_info.value.detail
 
@@ -433,7 +429,7 @@ async def test_resend_activation_link_already_activated() -> None:
     session.activation_links.append(link)
 
     with pytest.raises(BadRequestError) as exc_info:
-        await resend_activation_link(session=session, activation_id=link.id)
+        await auth_service.resend_activation_link(session=session, activation_id=link.id)
 
     assert "already activated" in exc_info.value.detail.lower()
 
@@ -453,7 +449,7 @@ async def test_resend_activation_link_not_expired_yet() -> None:
     session.activation_links.append(link)
 
     with pytest.raises(BadRequestError) as exc_info:
-        await resend_activation_link(session=session, activation_id=link.id)
+        await auth_service.resend_activation_link(session=session, activation_id=link.id)
 
     assert "not expired" in exc_info.value.detail.lower()
 
@@ -474,7 +470,7 @@ async def test_resend_activation_link_cooldown() -> None:
     session.activation_links.append(link)
 
     with pytest.raises(TooManyRequestsError) as exc_info:
-        await resend_activation_link(session=session, activation_id=link.id)
+        await auth_service.resend_activation_link(session=session, activation_id=link.id)
 
     assert "wait" in exc_info.value.detail.lower() or "email" in exc_info.value.detail.lower()
 
@@ -492,7 +488,7 @@ async def test_resend_activation_link_tenant_not_found() -> None:
     session.activation_links.append(link)
 
     with pytest.raises(NotFoundError) as exc_info:
-        await resend_activation_link(session=session, activation_id=link.id)
+        await auth_service.resend_activation_link(session=session, activation_id=link.id)
 
     assert "Account" in exc_info.value.detail
 
@@ -511,7 +507,9 @@ async def test_resend_activation_link_success_creates_new_link() -> None:
     )
     session.activation_links.append(link)
 
-    new_link, result_tenant = await resend_activation_link(session=session, activation_id=link.id)
+    new_link, result_tenant = await auth_service.resend_activation_link(
+        session=session, activation_id=link.id
+    )
 
     assert new_link.id is not None
     assert new_link.id != link.id
diff --git a/app/api/tests/unit/modules/email/test_service.py b/app/api/tests/unit/modules/email/test_service.py
index 9fe8cd0..2796b55 100644
--- a/app/api/tests/unit/modules/email/test_service.py
+++ b/app/api/tests/unit/modules/email/test_service.py
@@ -2,17 +2,18 @@ from unittest.mock import AsyncMock, patch
 
 import pytest
 
-from modules.email.service import send_activation_email
+from services.email_service import EmailService
 
 
 @pytest.mark.asyncio
 async def test_send_activation_email_raises_when_resend_api_key_missing() -> None:
-    with patch("modules.email.service.settings") as mock_settings:
+    with patch("services.email_service.settings") as mock_settings:
         mock_settings.RESEND_API_KEY = ""
         mock_settings.RESEND_FROM_EMAIL = "from@example.com"
+        email_service = EmailService()
 
         with pytest.raises(RuntimeError) as exc_info:
-            await send_activation_email(
+            await email_service.send_activation_email(
                 to_email="user@example.com",
                 restaurant_name="My Restaurant",
                 activation_link="https://example.com/activate?id=1",
@@ -23,12 +24,13 @@ async def test_send_activation_email_raises_when_resend_api_key_missing() -> Non
 
 @pytest.mark.asyncio
 async def test_send_activation_email_raises_when_resend_from_email_missing() -> None:
-    with patch("modules.email.service.settings") as mock_settings:
+    with patch("services.email_service.settings") as mock_settings:
         mock_settings.RESEND_API_KEY = "api-key"
         mock_settings.RESEND_FROM_EMAIL = ""
+        email_service = EmailService()
 
         with pytest.raises(RuntimeError) as exc_info:
-            await send_activation_email(
+            await email_service.send_activation_email(
                 to_email="user@example.com",
                 restaurant_name="My Restaurant",
                 activation_link="https://example.com/activate?id=1",
@@ -40,14 +42,15 @@ async def test_send_activation_email_raises_when_resend_from_email_missing() ->
 @pytest.mark.asyncio
 async def test_send_activation_email_calls_resend_with_correct_payload() -> None:
     with (
-        patch("modules.email.service.settings") as mock_settings,
-        patch("modules.email.service.asyncio.to_thread", new_callable=AsyncMock) as mock_to_thread,
+        patch("services.email_service.settings") as mock_settings,
+        patch("services.email_service.asyncio.to_thread", new_callable=AsyncMock) as mock_to_thread,
     ):
         mock_settings.RESEND_API_KEY = "test-key"
         mock_settings.RESEND_FROM_EMAIL = "noreply@restorio.com"
         mock_to_thread.return_value = None
+        email_service = EmailService()
 
-        await send_activation_email(
+        await email_service.send_activation_email(
             to_email="user@example.com",
             restaurant_name="My Restaurant",
             activation_link="https://example.com/activate?id=abc",
diff --git a/app/api/tests/unit/routes/v1/test_dto_common.py b/app/api/tests/unit/routes/v1/test_dto_common.py
index 1fb1418..f6d523a 100644
--- a/app/api/tests/unit/routes/v1/test_dto_common.py
+++ b/app/api/tests/unit/routes/v1/test_dto_common.py
@@ -1,7 +1,7 @@
 from pydantic import ValidationError
 import pytest
 
-from api.v1.dto.common import (
+from core.dto.v1.common import (
     BaseDTO,
     CurrencyCode,
     OrderStatus,
diff --git a/app/api/tests/unit/routes/v1/test_dto_menus.py b/app/api/tests/unit/routes/v1/test_dto_menus.py
index c73e752..a7ff42e 100644
--- a/app/api/tests/unit/routes/v1/test_dto_menus.py
+++ b/app/api/tests/unit/routes/v1/test_dto_menus.py
@@ -3,7 +3,7 @@ from decimal import Decimal
 from pydantic import ValidationError
 import pytest
 
-from api.v1.dto.menus import CreateMenuItemDTO, CreateModifierDTO, MenuItemDTO, ModifierDTO
+from core.dto.v1.menus import CreateMenuItemDTO, CreateModifierDTO, MenuItemDTO, ModifierDTO
 
 
 class TestCreateModifierDTO:
diff --git a/app/api/tests/unit/routes/v1/test_dto_orders.py b/app/api/tests/unit/routes/v1/test_dto_orders.py
index 7e5d6aa..5544c78 100644
--- a/app/api/tests/unit/routes/v1/test_dto_orders.py
+++ b/app/api/tests/unit/routes/v1/test_dto_orders.py
@@ -5,8 +5,8 @@ from uuid import uuid4
 from pydantic import ValidationError
 import pytest
 
-from api.v1.dto.common import OrderStatus
-from api.v1.dto.orders import (
+from core.dto.v1.common import OrderStatus
+from core.dto.v1.orders import (
     CreateOrderDTO,
     CreateOrderItemDTO,
     OrderItemResponseDTO,
diff --git a/app/api/tests/unit/routes/v1/test_dto_payments.py b/app/api/tests/unit/routes/v1/test_dto_payments.py
index ce0a06a..c384ac4 100644
--- a/app/api/tests/unit/routes/v1/test_dto_payments.py
+++ b/app/api/tests/unit/routes/v1/test_dto_payments.py
@@ -5,8 +5,8 @@ from uuid import uuid4
 from pydantic import ValidationError
 import pytest
 
-from api.v1.dto.common import PaymentProvider, PaymentStatus
-from api.v1.dto.payments import CreatePaymentDTO, PaymentResponseDTO, UpdatePaymentDTO
+from core.dto.v1.common import PaymentProvider, PaymentStatus
+from core.dto.v1.payments import CreatePaymentDTO, PaymentResponseDTO, UpdatePaymentDTO
 
 
 class TestCreatePaymentDTO:
diff --git a/app/api/tests/unit/routes/v1/test_dto_restaurants.py b/app/api/tests/unit/routes/v1/test_dto_restaurants.py
index 1fbd168..ff34858 100644
--- a/app/api/tests/unit/routes/v1/test_dto_restaurants.py
+++ b/app/api/tests/unit/routes/v1/test_dto_restaurants.py
@@ -4,7 +4,7 @@ from uuid import uuid4
 from pydantic import ValidationError
 import pytest
 
-from api.v1.dto.restaurants import (
+from core.dto.v1.restaurants import (
     CreateRestaurantTableDTO,
     RestaurantTableResponseDTO,
     UpdateRestaurantTableDTO,
diff --git a/app/api/tests/unit/routes/v1/test_dto_tenants.py b/app/api/tests/unit/routes/v1/test_dto_tenants.py
index cadef63..c603565 100644
--- a/app/api/tests/unit/routes/v1/test_dto_tenants.py
+++ b/app/api/tests/unit/routes/v1/test_dto_tenants.py
@@ -4,8 +4,8 @@ from uuid import uuid4
 from pydantic import ValidationError
 import pytest
 
-from api.v1.dto.common import TenantStatus
-from api.v1.dto.tenants import CreateTenantDTO, TenantResponseDTO, UpdateTenantDTO
+from core.dto.v1.common import TenantStatus
+from core.dto.v1.tenants import CreateTenantDTO, TenantResponseDTO, UpdateTenantDTO
 
 
 class TestCreateTenantDTO:
diff --git a/app/apps/admin-panel/src/features/floor/types.ts b/app/apps/admin-panel/src/features/floor/floorLayoutState.ts
similarity index 100%
rename from app/apps/admin-panel/src/features/floor/types.ts
rename to app/apps/admin-panel/src/features/floor/floorLayoutState.ts
diff --git a/app/apps/admin-panel/src/pages/FloorEditorPage.tsx b/app/apps/admin-panel/src/pages/FloorEditorPage.tsx
index 722f174..ef00f5d 100644
--- a/app/apps/admin-panel/src/pages/FloorEditorPage.tsx
+++ b/app/apps/admin-panel/src/pages/FloorEditorPage.tsx
@@ -1,4 +1,4 @@
-import type { FloorCanvas as FloorCanvasType, Venue } from "@restorio/types";
+import type { FloorCanvas as FloorCanvasType, Tenant } from "@restorio/types";
 import { useEffect, useState, type ReactElement } from "react";
 import { Navigate, useNavigate, useParams } from "react-router-dom";
 
@@ -8,14 +8,14 @@ import { FloorLayoutEditorView } from "../views/FloorLayoutEditorView";
 
 type LoadingState = "loading" | "loaded" | "error" | "not-found";
 
-const getActiveCanvas = (venue: Venue): FloorCanvasType | undefined => {
-  const canvases = venue.floorCanvases;
+const getActiveCanvas = (tenant: Tenant): FloorCanvasType | undefined => {
+  const canvases = tenant.floorCanvases;
 
   if (canvases.length === 0) {
     return undefined;
   }
 
-  return canvases.find((c) => c.id === venue.activeLayoutVersionId) ?? canvases[0];
+  return canvases.find((c) => c.id === tenant.activeLayoutVersionId) ?? canvases[0];
 };
 
 export const FloorEditorPage = (): ReactElement => {
@@ -23,7 +23,7 @@ export const FloorEditorPage = (): ReactElement => {
   const navigate = useNavigate();
 
   const [loadingState, setLoadingState] = useState<LoadingState>("loading");
-  const [venue, setVenue] = useState<Venue | null>(null);
+  const [tenant, setTenant] = useState<Tenant | null>(null);
 
   useEffect(() => {
     if (!venueId) {
@@ -32,7 +32,7 @@ export const FloorEditorPage = (): ReactElement => {
       return;
     }
 
-    const fetchVenue = async (): Promise<void> => {
+    const fetchTenant = async (): Promise<void> => {
       if (!venueId) {
         setLoadingState("not-found");
 
@@ -40,9 +40,9 @@ export const FloorEditorPage = (): ReactElement => {
       }
 
       try {
-        const data = await api.venues.get(venueId);
+        const data = await api.tenants.get(venueId);
 
-        setVenue(data);
+        setTenant(data);
         setLoadingState("loaded");
       } catch (error) {
         const httpError = error as { response?: { status?: number } };
@@ -55,7 +55,7 @@ export const FloorEditorPage = (): ReactElement => {
       }
     };
 
-    void fetchVenue();
+    void fetchTenant();
   }, [venueId]);
 
   const headerActions = (
@@ -78,7 +78,7 @@ export const FloorEditorPage = (): ReactElement => {
     );
   }
 
-  if (loadingState === "not-found" || !venue) {
+  if (loadingState === "not-found" || !tenant) {
     return <Navigate to="/" replace />;
   }
 
@@ -92,12 +92,12 @@ export const FloorEditorPage = (): ReactElement => {
     );
   }
 
-  const hasCanvases = venue.floorCanvases.length > 0;
-  const activeCanvas = hasCanvases ? getActiveCanvas(venue) : undefined;
+  const hasCanvases = tenant.floorCanvases.length > 0;
+  const activeCanvas = hasCanvases ? getActiveCanvas(tenant) : undefined;
 
   if (!hasCanvases || activeCanvas === undefined) {
     return (
-      <PageLayout title="Floor layout" description={venue.name} headerActions={headerActions}>
+      <PageLayout title="Floor layout" description={tenant.name} headerActions={headerActions}>
         <div className="flex flex-1 items-center justify-center p-8 text-center text-sm text-text-tertiary">
           No saved floor layouts exist for this venue yet. Add one from the venues list or contact support if you
           believe this is an error.
@@ -108,7 +108,7 @@ export const FloorEditorPage = (): ReactElement => {
 
   const handleSave = async (layout: FloorCanvasType): Promise<void> => {
     try {
-      await api.floorCanvases.update(venue.id, activeCanvas.id, {
+      await api.floorCanvases.update(tenant.id, activeCanvas.id, {
         name: layout.name,
         width: layout.width,
         height: layout.height,
@@ -120,7 +120,7 @@ export const FloorEditorPage = (): ReactElement => {
   };
 
   return (
-    <PageLayout title={`Floor: ${activeCanvas.name}`} description={venue.name} headerActions={headerActions}>
+    <PageLayout title={`Floor: ${activeCanvas.name}`} description={tenant.name} headerActions={headerActions}>
       <FloorLayoutEditorView initialLayout={activeCanvas} onSave={handleSave} />
     </PageLayout>
   );
diff --git a/app/apps/admin-panel/src/pages/VenuesPage.tsx b/app/apps/admin-panel/src/pages/VenuesPage.tsx
index a996578..b27cb08 100644
--- a/app/apps/admin-panel/src/pages/VenuesPage.tsx
+++ b/app/apps/admin-panel/src/pages/VenuesPage.tsx
@@ -1,4 +1,4 @@
-import type { VenueSummary } from "@restorio/types";
+import type { FloorCanvas, Tenant, TenantSummary } from "@restorio/types";
 import { useEffect, useState, type ReactElement } from "react";
 import { useNavigate } from "react-router-dom";
 
@@ -8,24 +8,48 @@ import { VenuesView } from "../views/VenuesView";
 
 type LoadingState = "loading" | "loaded" | "error";
 
+const getActiveCanvas = (tenant: Tenant): FloorCanvas | null => {
+  if (tenant.floorCanvases.length === 0) {
+    return null;
+  }
+
+  return tenant.floorCanvases.find((canvas) => canvas.id === tenant.activeLayoutVersionId) ?? tenant.floorCanvases[0];
+};
+
 export const VenuesPage = (): ReactElement => {
   const navigate = useNavigate();
   const [loadingState, setLoadingState] = useState<LoadingState>("loading");
-  const [venues, setVenues] = useState<VenueSummary[]>([]);
+  const [tenants, setTenants] = useState<TenantSummary[]>([]);
+  const [activeCanvasesByTenantId, setActiveCanvasesByTenantId] = useState<Record<string, FloorCanvas | null>>({});
 
   useEffect(() => {
-    const fetchVenues = async (): Promise<void> => {
+    const fetchTenants = async (): Promise<void> => {
       try {
-        const data = await api.venues.list();
+        const data = await api.tenants.list();
+        const tenantsWithCanvases = data.filter((tenant) => tenant.floorCanvasCount > 0);
+        const tenantDetails = await Promise.allSettled(tenantsWithCanvases.map((tenant) => api.tenants.get(tenant.id)));
+        const nextActiveCanvasesByTenantId: Record<string, FloorCanvas | null> = {};
+
+        tenantDetails.forEach((result, index) => {
+          if (result.status !== "fulfilled") {
+            return;
+          }
+
+          const tenantSummary = tenantsWithCanvases[index];
+          const activeCanvas = getActiveCanvas(result.value);
+
+          nextActiveCanvasesByTenantId[tenantSummary.id] = activeCanvas;
+        });
 
-        setVenues(data);
+        setTenants(data);
+        setActiveCanvasesByTenantId(nextActiveCanvasesByTenantId);
         setLoadingState("loaded");
       } catch {
         setLoadingState("error");
       }
     };
 
-    void fetchVenues();
+    void fetchTenants();
   }, []);
 
   if (loadingState === "loading") {
@@ -50,7 +74,12 @@ export const VenuesPage = (): ReactElement => {
 
   return (
     <PageLayout title="Venues" description="Manage venue floor layouts">
-      <VenuesView venues={venues} onSelectVenue={(venue) => navigate(`/venues/${venue.id}/floor`)} />
+      <VenuesView
+        venues={tenants}
+        activeCanvasesByVenueId={activeCanvasesByTenantId}
+        onSelectVenue={(tenant) => navigate(`/venues/${tenant.id}/floor`)}
+        onAddVenue={() => navigate("/venue-creator")}
+      />
     </PageLayout>
   );
 };
diff --git a/app/apps/admin-panel/src/views/FloorLayoutEditorView.tsx b/app/apps/admin-panel/src/views/FloorLayoutEditorView.tsx
index 9db8a40..31594fc 100644
--- a/app/apps/admin-panel/src/views/FloorLayoutEditorView.tsx
+++ b/app/apps/admin-panel/src/views/FloorLayoutEditorView.tsx
@@ -3,7 +3,7 @@ import { Button, FloorCanvas, useDragResize, type DragResizeMode, useSnapToGrid
 import type { ReactElement } from "react";
 import { useCallback, useEffect, useReducer, useState } from "react";
 
-import { createElementFromToAdd, layoutHistoryReducer } from "../features/floor/types";
+import { createElementFromToAdd, layoutHistoryReducer } from "../features/floor/floorLayoutState";
 
 const GRID_CELL = 20;
 const HANDLE_SIZE = 12;
@@ -88,13 +88,13 @@ export const FloorLayoutEditorView = ({ initialLayout, onSave }: FloorLayoutEdit
 
   const addElement = useCallback(
     (toAdd: ElementToAdd) => {
-      const el = createElementFromToAdd(toAdd, state.layout.venueId);
+      const el = createElementFromToAdd(toAdd, state.layout.tenantId);
       const x = 80 + (state.layout.elements.length % 5) * 100;
       const y = 80 + Math.floor(state.layout.elements.length / 5) * 100;
 
       dispatch({ type: "ADD_ELEMENT", payload: { element: el, x, y } });
     },
-    [state.layout.venueId, state.layout.elements.length],
+    [state.layout.tenantId, state.layout.elements.length],
   );
 
   const handleAddTable = useCallback(() => {
diff --git a/app/apps/admin-panel/src/views/VenuesView.tsx b/app/apps/admin-panel/src/views/VenuesView.tsx
index 369ccb9..e2363f3 100644
--- a/app/apps/admin-panel/src/views/VenuesView.tsx
+++ b/app/apps/admin-panel/src/views/VenuesView.tsx
@@ -1,41 +1,74 @@
-import type { VenueSummary } from "@restorio/types";
-import { Button } from "@restorio/ui";
+import type { FloorCanvas as FloorCanvasType, TenantSummary } from "@restorio/types";
+import { Button, FloorCanvas } from "@restorio/ui";
 import type { ReactElement } from "react";
 
 interface VenuesViewProps {
-  venues: VenueSummary[];
-  onSelectVenue: (venue: VenueSummary) => void;
+  venues: TenantSummary[];
+  activeCanvasesByVenueId?: Record<string, FloorCanvasType | null>;
+  onSelectVenue: (venue: TenantSummary) => void;
   onAddVenue?: () => void;
 }
 
-export const VenuesView = ({ venues, onSelectVenue, onAddVenue }: VenuesViewProps): ReactElement => {
+const PREVIEW_WIDTH = 180;
+const PREVIEW_HEIGHT = 120;
+
+const getPreviewTransform = (layout: FloorCanvasType): string => {
+  const scaleX = PREVIEW_WIDTH / layout.width;
+  const scaleY = PREVIEW_HEIGHT / layout.height;
+  const scale = Math.min(scaleX, scaleY);
+
+  return `scale(${scale})`;
+};
+
+export const VenuesView = ({
+  venues,
+  activeCanvasesByVenueId = {},
+  onSelectVenue,
+  onAddVenue,
+}: VenuesViewProps): ReactElement => {
   return (
     <div className="p-6">
       <div className="flex items-center justify-between gap-4 pb-4">
-        <h2 className="text-xl font-semibold text-text-primary">Venues</h2>
-        {onAddVenue && (
-          <Button variant="primary" size="sm" onClick={onAddVenue}>
-            Add venue
-          </Button>
-        )}
+        <Button variant="primary" size="sm" onClick={onAddVenue}>
+          Add venue
+        </Button>
       </div>
       {venues.length === 0 ? (
         <div className="text-center text-sm text-text-tertiary py-8">No venues found.</div>
       ) : (
         <ul className="flex flex-col gap-2">
-          {venues.map((venue) => (
-            <li key={venue.id}>
-              <button
-                type="button"
-                onClick={() => onSelectVenue(venue)}
-                className="w-full rounded-lg border border-border-default bg-surface-primary px-4 py-3 text-left transition-colors hover:bg-surface-secondary focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-border-focus"
-                aria-label={`Open floor layout for ${venue.name}`}
-              >
-                <span className="font-medium text-text-primary">{venue.name}</span>
-                <span className="ml-2 text-sm text-text-secondary">{venue.floorCanvasCount} floor(s)</span>
-              </button>
-            </li>
-          ))}
+          {venues.map((venue) => {
+            const activeCanvas = activeCanvasesByVenueId[venue.id];
+
+            return (
+              <li key={venue.id}>
+                <button
+                  type="button"
+                  onClick={() => onSelectVenue(venue)}
+                  className="w-full rounded-lg border border-border-default bg-surface-primary px-4 py-3 text-left transition-colors hover:bg-surface-secondary focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-border-focus"
+                  aria-label={`Open floor layout for ${venue.name}`}
+                >
+                  <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
+                    <div className="min-w-0">
+                      <span className="font-medium text-text-primary">{venue.name}</span>
+                      <span className="ml-2 text-sm text-text-secondary">{venue.floorCanvasCount} floor(s)</span>
+                    </div>
+                    {activeCanvas && (
+                      <div className="h-[120px] w-[180px] overflow-hidden rounded-md border border-border-default bg-background-secondary">
+                        <FloorCanvas
+                          layout={activeCanvas}
+                          showGrid={false}
+                          interactive={false}
+                          centered
+                          transformStyle={getPreviewTransform(activeCanvas)}
+                        />
+                      </div>
+                    )}
+                  </div>
+                </button>
+              </li>
+            );
+          })}
         </ul>
       )}
     </div>
diff --git a/app/apps/waiter-panel/src/App.tsx b/app/apps/waiter-panel/src/App.tsx
index a2a3fc2..9eb3a11 100644
--- a/app/apps/waiter-panel/src/App.tsx
+++ b/app/apps/waiter-panel/src/App.tsx
@@ -1,62 +1,19 @@
-import type { Venue } from "@restorio/types";
 import type { ReactElement } from "react";
-import { Navigate, Route, Routes, useNavigate, useParams } from "react-router-dom";
+import { Navigate, Route, Routes } from "react-router-dom";
 
-import { mockVenues } from "./features/floor/mockVenues";
 import { AppLayout } from "./layouts/AppLayout";
 import { PageLayout } from "./layouts/PageLayout";
-import { FloorRuntimeView } from "./views/FloorRuntimeView";
 
 const VenuesPage = (): ReactElement => {
-  const navigate = useNavigate();
-
   return (
-    <PageLayout title="Floor" description="Select a venue">
-      <div className="p-6">
-        <ul className="flex flex-col gap-2">
-          {mockVenues.map((venue) => (
-            <li key={venue.id}>
-              <button
-                type="button"
-                onClick={() => navigate(`/venues/${venue.id}`)}
-                className="w-full rounded-lg border border-border-default bg-surface-primary px-4 py-3 text-left transition-colors hover:bg-surface-secondary focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-border-focus"
-                aria-label={`Open floor for ${venue.name}`}
-              >
-                <span className="font-medium text-text-primary">{venue.name}</span>
-              </button>
-            </li>
-          ))}
-        </ul>
-      </div>
+    <PageLayout title="Floor" description="Waiter floor view">
+      <div className="p-6 text-sm text-text-tertiary">Floor runtime is not yet connected to live venues.</div>
     </PageLayout>
   );
 };
 
 const FloorPage = (): ReactElement => {
-  const { venueId } = useParams<{ venueId: string }>();
-  const venue = mockVenues.find((v: Venue) => v.id === venueId);
-  const navigate = useNavigate();
-
-  if (!venue) {
-    return <Navigate to="/" replace />;
-  }
-
-  return (
-    <PageLayout
-      title={venue.name}
-      headerActions={
-        <button
-          type="button"
-          onClick={() => navigate("/")}
-          className="text-sm font-medium text-interactive-primary hover:underline focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-border-focus"
-        >
-          Back
-        </button>
-      }
-    >
-      <FloorRuntimeView venue={venue} />
-    </PageLayout>
-  );
+  return <Navigate to="/" replace />;
 };
 
 export const App = (): ReactElement => {
diff --git a/app/apps/waiter-panel/src/features/floor/mockVenues.ts b/app/apps/waiter-panel/src/features/floor/mockVenues.ts
deleted file mode 100644
index 02c4c9e..0000000
--- a/app/apps/waiter-panel/src/features/floor/mockVenues.ts
+++ /dev/null
@@ -1,72 +0,0 @@
-import type { Venue } from "@restorio/types";
-import { createInitialLayout } from "@restorio/utils";
-
-export const mockVenues: Venue[] = [
-  {
-    id: "venue-1",
-    tenantId: "tenant-1",
-    name: "Main Restaurant",
-    activeLayoutVersionId: "canvas-venue-1-1",
-    floorCanvases: [
-      {
-        ...createInitialLayout("venue-1", "Main Hall", 800, 600),
-        elements: [
-          {
-            id: "el-1",
-            type: "table",
-            x: 80,
-            y: 80,
-            w: 80,
-            h: 80,
-            tableNumber: "1",
-            seats: 2,
-          },
-          {
-            id: "el-2",
-            type: "table",
-            x: 200,
-            y: 80,
-            w: 100,
-            h: 80,
-            tableNumber: "2",
-            seats: 4,
-          },
-          {
-            id: "el-3",
-            type: "bar",
-            x: 0,
-            y: 250,
-            w: 120,
-            h: 60,
-            label: "Bar",
-          },
-          {
-            id: "el-4",
-            type: "zone",
-            x: 400,
-            y: 40,
-            w: 350,
-            h: 200,
-            name: "Terrace",
-          },
-          {
-            id: "el-5",
-            type: "entrance",
-            x: 360,
-            y: 0,
-            w: 80,
-            h: 40,
-            label: "Entrance",
-          },
-        ],
-      },
-    ],
-  },
-  {
-    id: "venue-2",
-    tenantId: "tenant-1",
-    name: "Terrace Only",
-    activeLayoutVersionId: null,
-    floorCanvases: [createInitialLayout("venue-2", "Outdoor", 600, 400)],
-  },
-];
diff --git a/app/apps/waiter-panel/src/views/FloorRuntimeView.tsx b/app/apps/waiter-panel/src/views/FloorRuntimeView.tsx
index 2ebf30d..82e5c49 100644
--- a/app/apps/waiter-panel/src/views/FloorRuntimeView.tsx
+++ b/app/apps/waiter-panel/src/views/FloorRuntimeView.tsx
@@ -1,10 +1,10 @@
-import type { TableDisplayInfo, TableRuntimeState, Venue } from "@restorio/types";
+import type { FloorCanvas as FloorCanvasType, TableDisplayInfo, TableRuntimeState, Tenant } from "@restorio/types";
 import { FloorCanvas } from "@restorio/ui";
 import type { ReactElement } from "react";
 import { useCallback, useState } from "react";
 
 interface FloorRuntimeViewProps {
-  venue: Venue;
+  venue: Tenant;
   tableStates?: Record<string, TableRuntimeState>;
   tableDisplayInfo?: Record<string, TableDisplayInfo>;
 }
@@ -24,7 +24,7 @@ export const FloorRuntimeView = ({
   const hasCanvases = venue.floorCanvases.length > 0;
 
   const activeCanvas = hasCanvases
-    ? (venue.floorCanvases.find((c) => c.id === venue.activeLayoutVersionId) ?? venue.floorCanvases[0])
+    ? (venue.floorCanvases.find((c: FloorCanvasType) => c.id === venue.activeLayoutVersionId) ?? venue.floorCanvases[0])
     : undefined;
 
   const handleElementPointerDown = useCallback((id: string): void => {
diff --git a/app/packages/api-client/src/endpoints.ts b/app/packages/api-client/src/endpoints.ts
index fb5f7fe..424cc52 100644
--- a/app/packages/api-client/src/endpoints.ts
+++ b/app/packages/api-client/src/endpoints.ts
@@ -2,7 +2,7 @@ import type { ApiClient } from "./client";
 import {
   RestaurantsResource,
   TablesResource,
-  VenuesResource,
+  TenantsResource,
   FloorCanvasesResource,
   MenusResource,
   OrdersResource,
@@ -21,7 +21,7 @@ export class RestorioApi {
   public readonly menus: MenusResource;
   public readonly orders: OrdersResource;
   public readonly tables: TablesResource;
-  public readonly venues: VenuesResource;
+  public readonly tenants: TenantsResource;
   public readonly floorCanvases: FloorCanvasesResource;
 
   constructor(private client: ApiClient) {
@@ -32,6 +32,6 @@ export class RestorioApi {
     this.menus = new MenusResource(this.client);
     this.orders = new OrdersResource(this.client);
     this.tables = new TablesResource(this.client);
-    this.venues = new VenuesResource(this.client);
+    this.tenants = new TenantsResource(this.client);
   }
 }
diff --git a/app/packages/api-client/src/resources/floor-canvases.ts b/app/packages/api-client/src/resources/floor-canvases.ts
index 0f569a3..30c1321 100644
--- a/app/packages/api-client/src/resources/floor-canvases.ts
+++ b/app/packages/api-client/src/resources/floor-canvases.ts
@@ -4,62 +4,66 @@ import { BaseResource } from "./base";
 
 export class FloorCanvasesResource extends BaseResource {
   /**
-   * List all floor canvases for a venue.
-   * @param venueId - The ID of the venue to list the canvases for.
-   * @param signal - An optional abort signal to cancel the request.
-   * @returns A list of floor canvases for the venue.
+   * List floor canvases.
+   * @param tenantId - The ID of the tenant to list canvases for.
+   * @param signal - The abort signal to cancel the request.
+   * @returns A promise that resolves when the canvases are listed.
    */
-  list(venueId: string, signal?: AbortSignal): Promise<FloorCanvas[]> {
-    return this.client.get(`/venues/${venueId}/canvases`, { signal });
+  list(tenantId: string, signal?: AbortSignal): Promise<FloorCanvas[]> {
+    return this.client.get(`/tenants/${tenantId}/canvases`, { signal });
   }
 
   /**
-   * Get a specific floor canvas by its ID.
-   * @param venueId - The ID of the venue the canvas belongs to.
+   * Get a floor canvas.
+   * @param tenantId - The ID of the tenant to get the canvas for.
    * @param canvasId - The ID of the canvas to get.
-   * @returns The floor canvas.
+   * @param signal - The abort signal to cancel the request.
+   * @returns A promise that resolves when the canvas is retrieved.
    */
-  get(venueId: string, canvasId: string, signal?: AbortSignal): Promise<FloorCanvas> {
-    return this.client.get(`/venues/${venueId}/canvases/${canvasId}`, { signal });
+  get(tenantId: string, canvasId: string, signal?: AbortSignal): Promise<FloorCanvas> {
+    return this.client.get(`/tenants/${tenantId}/canvases/${canvasId}`, { signal });
   }
 
   /**
-   * Create a new floor canvas.
-   * @param venueId - The ID of the venue to create the canvas for.
-   * @param data - The data for the new canvas.
-   * @returns The created floor canvas.
+   * Create a floor canvas.
+   * @param tenantId - The ID of the tenant to create the canvas for.
+   * @param data - The data to create the canvas with.
+   * @param signal - The abort signal to cancel the request.
+   * @returns A promise that resolves when the canvas is created.
    */
   create(
-    venueId: string,
-    data: Omit<FloorCanvas, "id" | "venueId" | "version">,
+    tenantId: string,
+    data: Omit<FloorCanvas, "id" | "tenantId" | "version">,
     signal?: AbortSignal,
   ): Promise<FloorCanvas> {
-    return this.client.post(`/venues/${venueId}/canvases`, data, { signal });
+    return this.client.post(`/tenants/${tenantId}/canvases`, data, { signal });
   }
 
   /**
-   * Update a specific floor canvas.
-   * @param venueId - The ID of the venue the canvas belongs to.
+   * Update a floor canvas.
+   * @param tenantId - The ID of the tenant to update the canvas for.
    * @param canvasId - The ID of the canvas to update.
    * @param data - The data to update the canvas with.
-   * @returns The updated floor canvas.
+   * @param signal - The abort signal to cancel the request.
+   * @returns A promise that resolves when the canvas is updated.
    */
   update(
-    venueId: string,
+    tenantId: string,
     canvasId: string,
     data: Partial<Pick<FloorCanvas, "name" | "width" | "height" | "elements">>,
     signal?: AbortSignal,
   ): Promise<FloorCanvas> {
-    return this.client.put(`/venues/${venueId}/canvases/${canvasId}`, data, { signal });
+    return this.client.put(`/tenants/${tenantId}/canvases/${canvasId}`, data, { signal });
   }
 
   /**
-   * Delete a specific floor canvas.
-   * @param venueId - The ID of the venue the canvas belongs to.
+   * Delete a floor canvas.
+   * @param tenantId - The ID of the tenant to delete the canvas for.
    * @param canvasId - The ID of the canvas to delete.
+   * @param signal - The abort signal to cancel the request.
    * @returns A promise that resolves when the canvas is deleted.
    */
-  delete(venueId: string, canvasId: string, signal?: AbortSignal): Promise<void> {
-    return this.client.delete(`/venues/${venueId}/canvases/${canvasId}`, { signal });
+  delete(tenantId: string, canvasId: string, signal?: AbortSignal): Promise<void> {
+    return this.client.delete(`/tenants/${tenantId}/canvases/${canvasId}`, { signal });
   }
 }
diff --git a/app/packages/api-client/src/resources/index.ts b/app/packages/api-client/src/resources/index.ts
index 085223b..0b6c42a 100644
--- a/app/packages/api-client/src/resources/index.ts
+++ b/app/packages/api-client/src/resources/index.ts
@@ -2,6 +2,7 @@ export * from "./auth";
 export * from "./payments";
 export * from "./restaurants";
 export * from "./tables";
+export * from "./tenants";
 export * from "./floor-canvases";
 export * from "./menus";
 export * from "./orders";
diff --git a/app/packages/api-client/src/resources/tenants.ts b/app/packages/api-client/src/resources/tenants.ts
new file mode 100644
index 0000000..a8a6ed7
--- /dev/null
+++ b/app/packages/api-client/src/resources/tenants.ts
@@ -0,0 +1,33 @@
+import type { Tenant, TenantSummary } from "@restorio/types";
+
+import { BaseResource } from "./base";
+
+export class TenantsResource extends BaseResource {
+  async list(signal?: AbortSignal): Promise<TenantSummary[]> {
+    const response = await this.client.get<{ message: string; data: TenantSummary[] }>("/tenants", {
+      signal,
+    });
+
+    return response.data;
+  }
+
+  async get(tenantId: string, signal?: AbortSignal): Promise<Tenant> {
+    return this.client.get(`/tenants/${tenantId}`, { signal });
+  }
+
+  create(data: { name: string; slug: string; status?: string }, signal?: AbortSignal): Promise<Tenant> {
+    return this.client.post("/tenants", data, { signal });
+  }
+
+  update(
+    tenantId: string,
+    data: Partial<Pick<Tenant, "name" | "slug" | "status" | "activeLayoutVersionId">>,
+    signal?: AbortSignal,
+  ): Promise<Tenant> {
+    return this.client.put(`/tenants/${tenantId}`, data, { signal });
+  }
+
+  delete(tenantId: string, signal?: AbortSignal): Promise<void> {
+    return this.client.delete(`/tenants/${tenantId}`, { signal });
+  }
+}
diff --git a/app/packages/api-client/src/resources/venues.ts b/app/packages/api-client/src/resources/venues.ts
deleted file mode 100644
index c1bf76e..0000000
--- a/app/packages/api-client/src/resources/venues.ts
+++ /dev/null
@@ -1,61 +0,0 @@
-import type { Venue, VenueSummary } from "@restorio/types";
-
-import { BaseResource } from "./base";
-
-export class VenuesResource extends BaseResource {
-  /**
-   * List venues.
-   * @param tenantId - The ID of the tenant to list venues for.
-   * @returns A promise that resolves when the venues are listed.
-   */
-  async list(tenantId?: string, signal?: AbortSignal): Promise<VenueSummary[]> {
-    const response = await this.client.get<{ message: string; data: VenueSummary[] }>("/venues", {
-      params: tenantId ? { tenant_id: tenantId } : undefined,
-      signal,
-    });
-
-    return response.data;
-  }
-
-  /**
-   * Get a venue.
-   * @param venueId - The ID of the venue to get.
-   * @returns A promise that resolves when the venue is retrieved.
-   */
-  get(venueId: string, signal?: AbortSignal): Promise<Venue> {
-    return this.client.get(`/venues/${venueId}`, { signal });
-  }
-
-  /**
-   * Create a venue.
-   * @param tenantId - The ID of the tenant to create the venue for.
-   * @param data - The data to create the venue with.
-   * @returns A promise that resolves when the venue is created.
-   */
-  create(tenantId: string, data: { name: string }, signal?: AbortSignal): Promise<Venue> {
-    return this.client.post(`/venues/${tenantId}`, data, { signal });
-  }
-
-  /**
-   * Update a venue.
-   * @param venueId - The ID of the venue to update.
-   * @param data - The data to update the venue with.
-   * @returns A promise that resolves when the venue is updated.
-   */
-  update(
-    venueId: string,
-    data: Partial<Pick<Venue, "name" | "activeLayoutVersionId">>,
-    signal?: AbortSignal,
-  ): Promise<Venue> {
-    return this.client.put(`/venues/${venueId}`, data, { signal });
-  }
-
-  /**
-   * Delete a venue.
-   * @param venueId - The ID of the venue to delete.
-   * @returns A promise that resolves when the venue is deleted.
-   */
-  delete(venueId: string, signal?: AbortSignal): Promise<void> {
-    return this.client.delete(`/venues/${venueId}`, { signal });
-  }
-}
diff --git a/app/packages/api-client/tests/unit/resources/venues.test.ts b/app/packages/api-client/tests/unit/resources/venues.test.ts
deleted file mode 100644
index 82b5a23..0000000
--- a/app/packages/api-client/tests/unit/resources/venues.test.ts
+++ /dev/null
@@ -1,69 +0,0 @@
-/* eslint-disable @typescript-eslint/unbound-method */
-import { describe, it, expect, beforeEach, vi } from "vitest";
-
-import type { ApiClient } from "../../../src/client";
-import { VenuesResource } from "../../../src/resources";
-
-type ApiClientMock = Pick<ApiClient, "get" | "post" | "put" | "delete">;
-
-describe("VenuesResource", () => {
-  let client: ApiClientMock;
-  let resource: VenuesResource;
-
-  beforeEach(() => {
-    client = {
-      get: vi.fn().mockResolvedValue(undefined),
-      post: vi.fn().mockResolvedValue(undefined),
-      put: vi.fn().mockResolvedValue(undefined),
-      delete: vi.fn().mockResolvedValue(undefined),
-    };
-
-    resource = new VenuesResource(client as ApiClient);
-  });
-
-  it("list calls GET /venues without tenant filter", async () => {
-    await resource.list();
-
-    expect(client.get).toHaveBeenCalledWith("/venues", {
-      params: undefined,
-      signal: undefined,
-    });
-  });
-
-  it("list calls GET /venues with tenant filter", async () => {
-    await resource.list("tenant-1");
-
-    expect(client.get).toHaveBeenCalledWith("/venues", {
-      params: { tenant_id: "tenant-1" },
-      signal: undefined,
-    });
-  });
-
-  it("get calls GET /venues/:venueId", async () => {
-    await resource.get("venue-1");
-
-    expect(client.get).toHaveBeenCalledWith("/venues/venue-1", { signal: undefined });
-  });
-
-  it("create calls POST /venues/:tenantId", async () => {
-    await resource.create("tenant-1", { name: "Main Hall" });
-
-    expect(client.post).toHaveBeenCalledWith("/venues/tenant-1", { name: "Main Hall" }, { signal: undefined });
-  });
-
-  it("update calls PUT /venues/:venueId", async () => {
-    await resource.update("venue-1", { name: "Updated name", activeLayoutVersionId: "canvas-2" });
-
-    expect(client.put).toHaveBeenCalledWith(
-      "/venues/venue-1",
-      { name: "Updated name", activeLayoutVersionId: "canvas-2" },
-      { signal: undefined },
-    );
-  });
-
-  it("delete calls DELETE /venues/:venueId", async () => {
-    await resource.delete("venue-1");
-
-    expect(client.delete).toHaveBeenCalledWith("/venues/venue-1", { signal: undefined });
-  });
-});
diff --git a/app/packages/auth/src/RedirectAuthGuard.tsx b/app/packages/auth/src/RedirectAuthGuard.tsx
index dd151bf..42ad45b 100644
--- a/app/packages/auth/src/RedirectAuthGuard.tsx
+++ b/app/packages/auth/src/RedirectAuthGuard.tsx
@@ -25,7 +25,7 @@ export const RedirectAuthGuard = ({ children, redirectTo }: RedirectAuthGuardPro
     if (isAuthenticated()) {
       setAllowed(true);
     } else {
-      window.location.href = redirectTo;
+      // window.location.href = redirectTo;
     }
   }, [redirectTo]);
 
diff --git a/app/packages/types/src/floorCanvas.ts b/app/packages/types/src/floorCanvas.ts
index cd5f55a..d731223 100644
--- a/app/packages/types/src/floorCanvas.ts
+++ b/app/packages/types/src/floorCanvas.ts
@@ -65,7 +65,7 @@ export type FloorElement =
 
 export interface FloorCanvas {
   id: string;
-  venueId: string;
+  tenantId: string;
   name: string;
   width: number;
   height: number;
@@ -73,29 +73,12 @@ export interface FloorCanvas {
   version: number;
 }
 
-export interface Venue {
-  id: string;
-  tenantId: string;
-  name: string;
-  floorCanvases: FloorCanvas[];
-  activeLayoutVersionId: string | null;
-}
-
-export interface VenueSummary extends Omit<Venue, "floorCanvases"> {
-  floorCanvasCount: number;
-}
-
 export interface FloorLayoutEditorState {
   layout: FloorCanvas;
   history: FloorCanvas[];
   historyIndex: number;
 }
 
-export interface VenueOption {
-  venue: Venue;
-  activeCanvas: FloorCanvas | null;
-}
-
 export type ElementToAdd =
   | { type: "table"; tableNumber: string; seats: number }
   | { type: "tableGroup"; tableNumbers: string[]; seats: number }
diff --git a/app/packages/types/src/tenant.ts b/app/packages/types/src/tenant.ts
index cdced64..20ced66 100644
--- a/app/packages/types/src/tenant.ts
+++ b/app/packages/types/src/tenant.ts
@@ -1,13 +1,19 @@
+import type { FloorCanvas } from "./floorCanvas";
+
+export type TenantStatus = "ACTIVE" | "SUSPENDED" | "INACTIVE";
+
 export interface Tenant {
   id: string;
   name: string;
-  subdomain: string;
-  customDomain?: string;
-  ownerId: string;
+  slug: string;
+  status: TenantStatus;
+  activeLayoutVersionId: string | null;
+  floorCanvases: FloorCanvas[];
   createdAt: Date;
-  updatedAt: Date;
-  isActive: boolean;
-  trialEndsAt?: Date;
+}
+
+export interface TenantSummary extends Omit<Tenant, "floorCanvases"> {
+  floorCanvasCount: number;
 }
 
 export interface TenantSettings {
diff --git a/app/packages/utils/src/index.ts b/app/packages/utils/src/index.ts
index 4c36c0d..92ef696 100644
--- a/app/packages/utils/src/index.ts
+++ b/app/packages/utils/src/index.ts
@@ -1,2 +1,3 @@
 export * from "./environment";
 export * from "./initialState";
+export * from "./mocks/floor";
diff --git a/app/packages/utils/src/initialState/index.ts b/app/packages/utils/src/initialState/index.ts
index a4c8df9..c6a5c4c 100644
--- a/app/packages/utils/src/initialState/index.ts
+++ b/app/packages/utils/src/initialState/index.ts
@@ -1,8 +1,8 @@
 import type { FloorCanvas } from "@restorio/types";
 
-export const createInitialLayout = (venueId: string, name: string, width: number, height: number): FloorCanvas => ({
-  id: `canvas-${venueId}-1`,
-  venueId,
+export const createInitialLayout = (tenantId: string, name: string, width: number, height: number): FloorCanvas => ({
+  id: `canvas-${tenantId}-1`,
+  tenantId,
   name,
   width,
   height,
diff --git a/app/apps/admin-panel/src/features/floor/mockVenues.ts b/app/packages/utils/src/mocks/floor.ts
similarity index 68%
rename from app/apps/admin-panel/src/features/floor/mockVenues.ts
rename to app/packages/utils/src/mocks/floor.ts
index 79c7eb7..e2b77b9 100644
--- a/app/apps/admin-panel/src/features/floor/mockVenues.ts
+++ b/app/packages/utils/src/mocks/floor.ts
@@ -1,23 +1,13 @@
-import type { FloorCanvas, Venue } from "@restorio/types";
-import { createInitialLayout } from "@restorio/utils";
+import type { FloorCanvas, Tenant } from "@restorio/types";
 
-export const getVenueById = (id: string | undefined): Venue | undefined => mockVenues.find((v) => v.id === id);
+import { createInitialLayout } from "../initialState";
 
-export const getActiveCanvas = (venue: Venue): FloorCanvas | undefined => {
-  const canvases = venue.floorCanvases;
-
-  if (canvases.length === 0) {
-    return undefined;
-  }
-
-  return canvases.find((c) => c.id === venue.activeLayoutVersionId) ?? canvases[0];
-};
-
-export const mockVenues: Venue[] = [
+export const mockTenants: Tenant[] = [
   {
     id: "venue-1",
-    tenantId: "tenant-1",
     name: "Main Restaurant",
+    slug: "main-restaurant",
+    status: "ACTIVE",
     activeLayoutVersionId: "canvas-venue-1-1",
     floorCanvases: [
       {
@@ -73,12 +63,28 @@ export const mockVenues: Venue[] = [
         ],
       },
     ],
+    createdAt: new Date(),
   },
   {
     id: "venue-2",
-    tenantId: "tenant-1",
     name: "Terrace Only",
+    slug: "terrace-only",
+    status: "ACTIVE",
     activeLayoutVersionId: null,
     floorCanvases: [createInitialLayout("venue-2", "Outdoor", 600, 400)],
+    createdAt: new Date(),
   },
 ];
+
+export const getTenantById = (id: string | undefined): Tenant | undefined =>
+  mockTenants.find((tenant) => tenant.id === id);
+
+export const getActiveCanvas = (tenant: Tenant): FloorCanvas | undefined => {
+  const canvases = tenant.floorCanvases;
+
+  if (canvases.length === 0) {
+    return undefined;
+  }
+
+  return canvases.find((canvas) => canvas.id === tenant.activeLayoutVersionId) ?? canvases[0];
+};
